%-*- coding: UTF-8 -*-
\documentclass[UTF8]{ctexart}
\usepackage{geometry}
\geometry{a4paper,centering,scale=0.8}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{float}
\usepackage{minted}

\title{\heiti Python 基础篇}
\author{卢婧宇}

\begin{document}
\maketitle
\tableofcontents

\newpage
\section{开胃菜}
虽然 Python 易于使用，但它却是一门完整的编程语言；与 Shell 脚本或批处理文件相比，它为编写大型程序提供了更多的结构和支持。
另一方面，Python提供了比C更多的错误检查，并且作为一门高级语言，它内置支持高级的数据结构类型，例如：灵活的数组和字典。

Python允许你将程序分割为不同的模块，以便在其他的Python程序中重用。Python内置提供了大量的标准模块，你可以将其用作程序的基础，
或者作为学习Python编程的示例。这些模块提供了诸如文件I/O、系统调用、Socket支持，甚至类似Tk的用户图形界面（GUI)工具包借口。

Python是一门解释型语言，因为无需编译和链接，你可以在程序开发中节省宝贵的时间。Python解释器可以交互的使用，这使得试验语言的特性、
编写临时程序或在自底向上的程序开发中测试方法非常容易。你甚至还可以把它当做一个桌面计算器。

Python让程序编写的紧凑和可读。用Python编写的程序通常比同样的C、C++或Java程序更短小，原因如下：
\begin{itemize}
  \item 高级数据结构使你可以在一条语句中表达复杂的操作
  \item 语句组使用缩进代替开始和结束大括号来组织
  \item 变量或参数无需声明
\end{itemize}

Python是可扩展的：如果你会C语言编程便可以轻易地为解释器\footnote{解释器，又译为直译器，是一种电脑程序，能够把高级编程语言一行一行直接转译运行。}
添加内置函数或模块，或者为了对性能瓶颈作优化，或者将Python程序与只有二进制形式的库（比如末各专业的商业图形库）连接起来。
一旦你真正掌握了它，你可以将Python解释器集成进某个C应用程序，并把它当作那个程序的扩展命令行语言。
\section{使用Python解释器}
\subsection{调用Python解释器}
Python解释器通常被安装在目标机器的 $/$usr$/$local$/$bin$/$python3.5 目录下。将 $/$usr$/$local$/$bin 目录包含进 Unix shell的搜索路径里，
以确保可以通过输入：Python3.5 命令启动。由于Python解释器的安装路径是可选的，这也可能是其他路径，你可以联系安装Python的用户或系统管理员确认
（例如，/usr/local/python 就是一个常见的选择）。文件结束符Unix系统是：Control + D

第二种启动Python解释器的方法是 Python -c command [arg] ...,这种方法可以在命令行执行Python语句，类似于shell中的 -c选项。由于Python语句通常会包含
空格或其他特殊shell字符，一般建议将命令用单引号包裹起来。

有一些Python模块也可以当做脚本使用。你可以使用 python -m module [arg] ... 命令调用它们，这类似在命令行中键入完整的路径名执行模块源文件一样。
使用脚本文件时，经常会运行脚本然后进入交互模式。这也可以通过在脚本之前加上 -i参数来实现。
\subsubsection{交互模式}
从tty读取命令时，我们称解释器工作于交互模式。这种模式下他根据主提示符来执行，主提示符通常标识为三个大于号（$>>>$);继续的部分被称为从属提示符，由三个
点标识（...)。在第一行之前，解释器打印欢迎信息、版本号和授权提示
\subsubsection{参数传递}
调用解释器时，脚本名和附加参数传入一个名为 sys.argv的字符串列表。你能够获取这个列表通过执行 import sys,列表的长度大于等于1；
没有给定脚本和参数时，它至少也有一个元素：sys.argv[0]此时为空字符串。脚本名指定为`-'（表示标准输入）时，sys.argv[0]被定义为`-',使用 -c 指令时，sys.argv[0]
被设定为`-c'。使用-m模块参数时，sys.argv[0]被设定为指定模块的全名。-c 指令或者 -m 模块之后的参数不会被Python解释器的选项处理机制所截获，而是留在sys.argv中，
供脚本命令操作。
\section{Python简介}
输入和输出分别由大括号和句号提示符（$>>>$ 和 ...)标注。

Python中的注释以\#字符起始，直至实际的行尾。注释可以从行首开始，也可以在空白或代码之后，但是不出现在字符串中。
文本字符串中的\#字符仅仅表示\#。
\subsection{将Python当做计算器}
\subsubsection{数字}
解释器表现得就像一个简单的计算器：可以向其录入一些表达式，它会给出返回值。表达式语法很直白：运算符$+，-，*$和$/$与其他语言一样；括号用于分组。

整数（例如，2，4，20）的类型是int，带有小数部分的数字（例如，5.0，1.6）的类型是float。Python2除法想要得到浮点型，除数或被除数应是浮点型。
Python3除法（$/$）永远返回一个浮点数,如果要使用floor除法并且得到整数结果（丢掉任何小数部分），可以使用（$//$）运算符；要计算余数使用 \% 。
可以使用$**$运算符计算幂乘方。用等号（$=$）用于给变量赋值。赋值之后在下一个提示符之前不会有任何结果显示。

变量在使用前必须“定义”（赋值），否则会出错。浮点数有完整的支持；整数和浮点数的混合计算中，整数会被转换为浮点数。

交互模式中，最近一个表达式的值赋给变量`\_'。这样我们就可以吧它当做一个桌面计算器：

\begin{minted}{python}
>>> t=12.5/100
>>> p=100.50
>>> p*t
12.5625
>>> p+ _
113.0625
\end{minted}

此变量对于用户是只读的。不要尝试给它赋值——你只会创建一个独立的同名局部变量，它屏蔽了系统内置变量的魔术效果。

除了int和float，Python还会支持其它数字类型，例如Decimal和Fraction。Python还内建支持复数，使用后缀 j 或 J 表示虚数部分
（例如，3+5j）。
\subsubsection{字符串}
相比数值，Python也提供了可以通过几种不同方式表示的字符串。它们可以用单引号（`...')或双引号（``...''）标识。
 \textbackslash 可以用来转义引号：
\begin{minted}{python}
>>> 'spam eggs' #single quotes
'spam eggs'
>>>'doesn\'t'  #use \' to escape the single quote...
"doesn't"
>>> '"Yes,"he said.'
'"Yes,"he said.'
>>> "\"Yes,\"he said."
'"Yes,"he said.'
>>> '"Isn\'t,"she said.'
'"Isn\'t,"she said.'
\end{minted}

在交互式解释其中，输出的字符串会用引号引起来，特殊字符会用反斜杠转义。虽然可能和输入看上去不太一样，但是两个字符串是相等的。
如果字符串中只有单引号而没有双引号，就用双引号引用，否则用单引号引用。
print()函数生成可读性更好的输出，它会省去引号并且打印出转义后的特殊字符：
\begin{minted}{python}
>>> '"Isn\'t,"she said.'
'"Isn\'t,"she said.'
>>> print('"Isn\'t." she said.')
"Isn't." she said.
>>> s='First line.\nSecond line.'  # \n means newline
>>> s  # without print(), \n is included in the output
'First line.\nSecond line.'
>>> print(s)  #with print(),\n produces a new line
First line.
Second line.
\end{minted}

如果你前面带有 \textbackslash 的字符被当作特殊字符，你可以使用原始字符串，方法是在第一个引号前面加上一个r。

字符串文本能够分成多行。一种方法是使用三引号：\verb|"""|...\verb|"""|或者 ```...'''。行尾换行符会自动包含到字符串中，
但是可以在行尾加上 \textbackslash
来避免这个行为。可以使用反斜杠为行结尾的字符串，他表示下一行在逻辑上是本行的后续内容。

字符串可以由 $+$ 操作符连接（粘到一起），可以由 $*$ 表示重复。相邻两个字符串文本自动连接在一起。
它只用于两个字符串文本，不能用于字符串表达式：
\begin{minted}{python}
>>> prefix='Py'
>>> prefix 'thon' # can't concatenate a variable and a string literal
...
SyntaxError: invalid syntax
>>> ('un'*3) 'ium'
...
SyntaxError: invalid syntax
\end{minted}


如果你想连接多个变量或者连接一个变量和一个字符串文本，使用 $+$。这个功能在你想切分很长的字符串的时候特别有用:
\begin{minted}{python}
>>> text=('Put several string within parerheses'
...       'to have them joined together.')
>>> text
'Put several string within parerhesesto have them joined together.'
\end{minted}

字符串也可以被截取（检索）。类似于C，字符串的第一个字符索引为0。Python没有单独的字符类型；一个字符就是一个简单的长度为1的字符串。
\begin{minted}{python}
>>> word='Python'
>>> word[0] # character in position 0
'P'
>>> word[5] # character in position 5
'n'
\end{minted}
索引也可以是负数，这将导致从右边开始计算。例如：
\begin{minted}{python}
>>> word[-1] #last character
'n'
>>> word[-2] #second-last character
'o'
>>> word[-6]
'P'
\end{minted}

请注意$-0$实际上就是0，所以他不会导致从右边开始计算。

除了索引，还支持切片。索引用于获得单个字符，切片让你获得一个子字符串:
\begin{minted}{python}
>>> word[0:2] # character from position 0(included)to 2 (excluded)
'Py'
>>> word[2:5] # character from position 2(included) to 5(excluded)
'tho'
\end{minted}

注意，包含起始的字符，不包含末尾的字符。这使得s[:i]+s[i:]永远等于s,：
\begin{minted}{python}
>>> word[:2]+word[2:]
'Python'
>>> word[:4]+word[4:]
'Python'
\end{minted}

切片的索引有非常有用的默认值；省略的第一个索引默认为零，省略的第二个索引默认为切片的字符串的大小。:
\begin{minted}{python}
>>> word[:2]
'Py'
>>> word[4:]
'on'
>>> word[-2:]
'on'
\end{minted}

有个办法可以很容易地记住切片的工作方式：切片时的索引是在两个字符之间。左边第一个字符的索引为0，而长度为n的字符串最后一个字符的右界索引为n。例如：

+---+---+---+---+---+---+

| P | y | t | h | o | n |

+---+---+---+---+---+---+

0   1   2   3   4   5   6

-6  -5  -4  -3  -2  -1

文本中的第一行数字给出字符串的索引点0...6。第二行给出相应的负索引。切片是从i到j两个数值表示的边界之间的所有字符。

对于非负索引，如果上下都在边界内，切片长度就是两个索引之差。

试图使用太大索引会导致错误。
\begin{minted}{python}
>>> word[42] # the word only has 6 characters
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
\end{minted}

Python能够优雅地处理那些没有意义的切片索引：一个过大的索引值（即下标值大于字符串实际长度）将被字符串实际长度所替代，
当上边界比下边界大时（即切片左值大于右值）就返回空字符串:
\begin{minted}{python}
>>> word[4:42]
'on'
>>> word[42:]
''
\end{minted}

Python字符串不可以被更改——它们是不可变的。因此，赋值给字符串索引的位置会导致错误。:
\begin{minted}{python}
>>> word[0]='J'
...
TypeError: 'str' object does not support item assignment
>>> word[2:]='py'
...
TypeError: 'str' object does not support item assignment
\end{minted}

如果你需要一个不同的字符串，你应该创建一个新的:
\begin{minted}{python}
>>> 'J'+word[1:]
'Jython'
>>> word[:2]+'py'
'Pypy'
\end{minted}

内置函数 len() 返回字符串长度:
\begin{minted}{python}
>>> s='supercalifragilisticexpialidocious'
>>> len(s)
34
\end{minted}

\subsubsection{列表}
Python有几个复合数据类型，用于表示其它的值。最通用的是list（列表），它可以写作中括号之间的一列逗号分隔的值。列标的元素不必是同一类型：
\begin{minted}{python}
>>> squares=[1, 4, 9, 16, 25]
>>> squares
[1, 4, 9, 16, 25]
\end{minted}

就像字符串（以及其它所有内建的序列类型）一样，列表可以被索引和切片：
\begin{minted}{python}
>>> squares[0] # indexing returns the item
1
>>> squares[-1]
25
>>> squares[-3:] #slicing return a new list
[9, 16, 25]
\end{minted}

所有的切片操作都会返回一个包含请求的元素的新列表。这意味着下面的切片操作返回列表一个新的（浅）拷贝副本：
\begin{minted}{python}
>>> squares[:]
[1, 4, 9, 16, 25]
\end{minted}

列表也支持连接这样的操作：
\begin{minted}{python}
>>> squares + [36, 49, 64, 81, 100]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
\end{minted}

不像不可变的字符串，列表是可变的，它允许修改元素：
\begin{minted}{python}
>>> cubes=[1, 8, 27, 65, 125] #something's wrong here
>>> 4 ** 3 #the cub of 4 is 64,not 65!
64
>>> cubes[3]=64 # replace the wrong value
>>> cubes
[1, 8, 27, 64, 125]
\end{minted}

还可以使用 append()方法在列表的末尾添加新的元素:
\begin{minted}{python}
>>> cubes.append(216) #add the cube of 6
>>> cubes.append(7 ** 3) # add the cube of 7
>>> cubes
[1, 8, 27, 64, 125, 216, 343]
\end{minted}

也可以对切片赋值，此操作可以改变列表的尺寸，或清空它：
\begin{minted}{python}
  >>> letters=['a','b','c','d','e','f','g']
  >>> letters
  ['a', 'b', 'c', 'd', 'e', 'f', 'g']
  >>> #replace some values
  ... letters[2:5]=['C','D','E']
  >>> letters
  ['a', 'b', 'C', 'D', 'E', 'f', 'g']
  >>> # now remove them
  ... letters[2:5]=[]
  >>> letters
  ['a', 'b', 'f', 'g']
  >>> # clear the list by replacing all the elements with an empty list
  ... letters[:]=[]
  >>> letters
  []
\end{minted}

内置函数 len() 同样适用于列表：
\begin{minted}{python}
  >>> letters=['a','b','c','d']
  >>> len(letters)
  4
\end{minted}

允许嵌套列表（创建一个包含洽谈列表的列表），例如：
\begin{minted}{python}
>>> a=['a','b','c']
>>> n=[1,2,3]
>>> x=[a,n]
>>> x
[['a', 'b', 'c'], [1, 2, 3]]
>>> x[0][1]
'b'
\end{minted}

\subsection{编程的第一步}
当然，我们可以使用Python完成比二加二更复杂的任务。例如，我们可以写一个生成斐波那契子程序的程序，如下所示：
\begin{minted}{python}
>>> # Fibonacci series:
... # the sum of two elements defines the next
... a, b = 0,1
>>> while b<10:
...    print(b)
...    a, b = b, a+b
...
1
1
2
3
5
8
\end{minted}

这个例子介绍了几个新功能。
\begin{itemize}
  \item 第一行包括了一个多重赋值：变量a 和b同时获得了新的值0和1最后一行又使用了一次。在这个演示中，变量赋值前，右边首先完成计算。右边的
  表达式从左到右计算。
  \item 条件（这里是 b<10）为true时，while循环执行。在Python中，类似于C，任何非零整数都是true;0是false。条件也是可以
  是字符串或列表，实际上可以使任何序列；所有长度不为零的是true，空序列是false。示例中的测试是一个检点的比较。
  标准比较操作符与C相同：< , > , == , <= , >= 和 ！=。
  \item 循环体是缩进的：缩进是Python组织语句的方法。Python(还)不提供集成的行编辑功能，所以你要为每一个缩
  进行输入TAB或空格。

  实践中建议你找个文本编辑来录入复杂的Python程序，大多数文本编辑器提供自动缩进。交互式录入复合语句时，必须在最后一个
  空行来标识结束（因为解释器没办法猜测你输入的哪一行是最后一行），需要注意的是同一个语句块中的每一行必须缩进同样数量的空白
  \item 关键字print() 语句输出给定表达式的值。它控制多个表达式和字符串输出为你想要字符串（就像在前面计算器的例子中那样）。

  字符串打印时不用引号包围，每两个子项之间插入空间，所以你可以把格式弄得很漂亮，像这样
  \begin{minted}{python}
    >>> i=256*256
    >>> print('The value of i is',i)
    The value of i is', 65536
  \end{minted}

  一个逗号结尾就可以禁止输出换行：
  \begin{minted}{python}
    >>> a, b=0 ,1
    >>> while b < 1000:
    ...     print(b, end=',')
    1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,
  \end{minted}
\end{itemize}

\section{深入Python流程控制}
除了前面介绍的while语句，Python还从其他语言借鉴了一些流程控制功能，并有所改变。
\subsection{if语句}
也许最有名的就是if语句。例如：
\begin{minted}{python}
  >>> x = int(input("Please enter an integer: "))
  Please enter an integer: 42
  >>> if x < 0:
  ...     x = 0
  ...     print('Negative changed to zero')
  ... elif x==0:
  ...     print('Zero')
  ... elif x==1:
  ...     print('Single')
  ... else:
  ...     print('More')
  ...
  More
\end{minted}
可能会有零到多个elif部分，else是可选的。关键字`elif'是`else if'的缩写，这个可以有效地避免
过深的缩进。if ... elif ... elif ...序列用于代替其他语言中的 swith 或 case 语句。
\subsection{for语句}
Python中的for语句和C或Pascal中的略有不同。通常的循环可能会依据一个等差数值步进过程（如Pascal）
，或由用户来定义迭代步骤和终止条件（如C），Python的for语句依据任意序列（链表或字符串）中的子项
，按它们在序列中的顺序来进行迭代。例如（没有暗指）：
\begin{minted}{python}
>>> # Measure some strings:
... words = ['cat', 'window', 'defenestrate']
>>> for w in words:
...     print(w, len(w))
...
cat 3
window 6
defenestrate 12
\end{minted}
在迭代过程中修改序列不安全（只有在使用链表这样的可变序列时才会有这样的情况）。
如果你想要修改你的迭代的序列（例如，复制选择项），你可以迭代它的副本。使用切割标识就可以很方便
的做到这一点：
\begin{minted}{python}
>>> for w in words[:]:
...     if len(w) > 6:
...             words.insert(0, w)
...
>>> words
['defenestrate', 'cat', 'window', 'defenestrate']
\end{minted}
\subsection{range()函数}
如果你需要一个数值序列，内置函数range()会很方便，它生成一个等差级数链表：
\begin{minted}{python}
>>> for i in range(5):
...     print(i)
...
0
1
2
3
4
\end{minted}
range(10)生成了一个包含10个值的链表，他用链表的索引值填充了这个长度为10的列表，
所生成的链表中不包括范围中的结束值。也可以让range()操作从另一个数值开始，或者可以指定一个不同
的步进值（甚至是负数，有时这也被称为步长)
\begin{minted}{python}
range(5, 10)
  5 through 9
range(0, 10, 3)
  0, 3, 6, 9
range(-10, -100, -30)
  -10, -40, -70
\end{minted}
需要迭代链表索引的话，如下所示结合使用用 range() 和 len()
\begin{minted}{python}
>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
...     print(i, a[i])
...
0 Mary
1 had
2 a
3 little
4 lamb
\end{minted}
不过，这种场合可以方便的使用 enumerate(),请参见 循环技巧。

如果你只是打印一个序列的话会发生奇怪的事情：
\begin{minted}{python}
>>> print(range(10))
range(0, 10)
\end{minted}
在不同方面range()函数返回的对象表现为它是一个列表，但事实上它并不是。当你迭代它时，
它是一个能够像期望的序列返回连续项的对象；但为了节省空间，他并不真正构造列表。

我们称此类对象是可迭代的，即适合作为那些期望从某些东西中获得连续项直到结束的函数
或结构的一个目标（参数）。我们已经见过的for语句就是这样一个迭代器。list()函数是
另外一个（迭代器），他从可迭代（对象）中创建列表：
\begin{minted}{python}
>>> list(range(5))
[0, 1, 2, 3, 4]
\end{minted}
稍后我们会看到更多返回可迭代（对象）和以可迭代（对象）作为参数的函数。

\subsection{break 和 continue 语句，以及循环中的else子句}
break语句和C中的类似，用于跳出最近的一级for或while循环。

循环可以有一个else子句；它在循环迭代完整个列表（对于for）或执行条件为false（对于while）时
执行，但循环被break中止的情况不会执行。以下搜索素数的示例程序演示了这个子句：
\begin{minted}{python}
>>> for n in range(2, 10):
...     for x in range(2, n):
...             if n % x == 0:
...                     print(n, 'equals', x, '*', n//x)
...                     break
...     else:
...         # loop fell through without finding s factor
...             print(n, 'is a prime number')
...
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3
\end{minted}
(Yes,这是正确的代码。看仔细：else 语句是属于 for 循环之中，不是 if 语句。)

与循环一起使用时，else子句与try语句的else子句比与if语句的具有更多的共同特点：try 语句的 else
子句在未出现异常时运行，循环的else子句在未出现break时运行。更多关于 try 语句和异常的内容，请参见异常处理。

continue 语句是从C中借鉴来的，它表示循环继续执行下一次迭代：
\begin{minted}{python}
  >>> for num in range(2, 10):
  ...     if num % 2 ==0:
  ...             print("Found an even number", num)
  ...             continue
  ...     print("Found a number", num)
  ...
  Found an even number 2
  Found a number 3
  Found an even number 4
  Found a number 5
  Found an even number 6
  Found a number 7
  Found an even number 8
  Found a number 9
\end{minted}

\subsection{pass语句}
pass语句什么也不做。它用于那些语法上必须要有什么语句，但程序什么也不做的场合，例如：
\begin{minted}{python}
  >>> while True:
  ...     pass # Busy-wait for keyboard interrupt (Ctrl+C)
  ...
\end{minted}
者通常用于创建最小结构的类：
\begin{minted}{python}
>>> class MyEmptyClass:
...     pass
...
\end{minted}
另一方面，pass可以在创建新代码时用来做函数或控制体的占位符。可以让你在更抽象的级别上思考。
pass可以默默的被忽视：
\begin{minted}{python}
>>> def initlog(*args):
...     pass  # Remember to implement this!
...
\end{minted}

\subsection{定义函数}
我们可以创建一个用来生成指定边界的斐波那契数列的函数：
\begin{minted}{python}
>>> def fib(n):  # write Fibonacci series up to n
...     """Print a Fibonacci series up to n."""
...     a, b = 0, 1
...     while a < n:
...             print(a, end=' ')
...             a, b = b, a+b
...     print()
...
>>> # Now call the function we just defined:
... fib(2000)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
\end{minted}

关键字 def 引入了一个函数定义。在其后必须跟有函数名和包括形式参数的圆括号。函数体语句从下一行
开始，必须是缩进的。

函数体第一行语句可以是可选的字符串文本，这个字符串是函数的文档字符串，或者称为 docstring。（更多关于 docstring 的
信息请参考文档字符串）有些工具通过 docstrings 自动生成在线的或可打印的文档，或者让用户通过代码交互浏览；
在你的代码中包含 docstrings 是一个好的实践，让它成为习惯吧。

函数调用会为函数局部变量生成一个新的符号表。确切的说，所有函数中的变量赋值都是将值存储在局部符号表。变量引用首先在局部符号表中
查找，然后是包含函数的局部符号表，最后是内置名字表。因此，全局变量不能在函数中直接赋值（除非用 global语句命名），尽管他们可以被引用。

函数引用的实际参数在函数调用时引入局部符号表，因此，实参总是传值调用（这里的值总是一个对象引用，而不是该对象的值）。
一个函数被另一个函数调用时，一个新的局部符号表在调用过程中被创建。

一个函数定义会在当前符号表内引入函数名。函数名指代的值（即函数体）有一个被Python 解释器认定为用户自定义函数的类型。这个值可以
赋予其他的名字（即变量名），然后它也可以被当做函数使用。这可以作为通用的重命名机制：
\begin{minted}{python}
>>> fib
<function fib at 0x102aa29d8>
>>> f=fib
>>> f(100)
0 1 1 2 3 5 8 13 21 34 55 89
\end{minted}
如果你使用过其他语言，你可能会反对说：fib不是一个函数，而是一个方法因为它并不返回任何值。事实上，没有return语句的函数确实会返回一个值，
虽然是一个相当令人厌烦的值（指None）。这个值被称为None(这是一个内建名称)。如果None值是唯一被书写的值，那么在写的时候通常会被解释器
忽略（即不输出任何内容）。如果你确实想看到这个值的输出内容，请使用print()函数：
\begin{minted}{python}
>>> fib(0)
>>> print(fib(0))
None
\end{minted}

定义一个返回斐波那契数列数字列表的函数，而不是打印它，是很简单的：
\begin{minted}{python}
>>> def fib2(n): #return Fibonacci series up to n
...     """Return a list containing the Fibonacci series up to n."""
...     result = []
...     a, b = 0, 1
...     while a < n:
...             result.append(a)  # see below
...             a, b = b, a+b
...     return result
...
>>> f100 = fib2(100) # call it
>>> f100             # write the reslut
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
\end{minted}

和以前一样，这个例子演示了一些新的Python功能：
\begin{itemize}
  \item return语句从函数中返回一个值，不带表达式的return返回None。过程结束后也会返回None。
  \item 语句result.append(b)称为链表对象 result的一个方法。方法是一个``属于''某个对象的函数，它被命名为obj.methodename,
  这里的obj是某个对象（可能是一个表达式），methodename是某个在该对象类型定义中的方法的命名。

  不同类型定义不同的方法。不同类型可能有同样名字的方法，但不会混淆。（当你定义自己的对象类型和方法时，可能会出现这种情况，
  class的定义方法详见类）。示例中演示的 append()方法由链表对象定义，它向链表中加入一个新元素。在示例中他等同于
  result =result +[a],不过效率更高。
\end{itemize}

\subsection{深入Python函数定义}
在Python中，你也可以定义包含若干参数的函数。这里有三种可用的形式，也可以混合使用。
\subsubsection{默认参数值}
最常用的一种形式是为一个或多个参数指定默认值。这会创建一个可以使用比定义时允许的参数更少的参数调用的函数，例如:
\begin{minted}{python}
>>> def ask_ok(prompt, retries=4, complaint='Yes or no, please!'):
...     while True:
...             ok = input(prompt)
...             if ok in ('y', 'ye', 'yes'):
...                     return Ture
...             if ok in ('n', 'no', 'nop', 'nope'):
...                     return False
...             retries = retries - 1
...             if retries < 0:
...                     raise OSError('uncooperat user')
...             print(complaint)
\end{minted}

这个函数可以通过几种不同的方式调用：
\begin{itemize}
  \item 只给出必要的参数：ask\_ok $($`Do you really want to quit?'$)$
  \item 给出一个可选的参数：

  ask\_ok$($`Ok to overwrite the file?', 2$)$
  \item 或者给出所有的参数：

  ask\_ok$($`OK to overwrite the file?', 2, `Come only yes or no!'$)$
\end{itemize}

这个例子还介绍了 in 关键字。它测定序列中是否包含某个确定的值。

默认值在函数定义作用域被解析，如下所示：
\begin{minted}{python}
>>> i = 5
>>> def f(arg = i):
...     print(arg)
...
>>> i = 6
>>> f()
5
\end{minted}

重要警告：默认值只被赋值一次。这使得当默认值是可变对象时会有所不同，比如列表、字典或者大多数类的实例。
例如，下面的函数在后续调用过程中会累积（前面）传给它的参数：
\begin{minted}{python}
>>> def f(a, L=[]):
...     L.append(a)
...     return L
...
>>> print(f(1))
[1]
>>> print(f(2))
[1, 2]
>>> print(f(3))
[1, 2, 3]
\end{minted}

如果你不想让默认值在后续调用中累积，你可以像下面一样定义函数：
\begin{minted}{python}
>>> def f(a, L=None):
...     if L is None:
...             L = []
...     L.append (a)
...     return L
\end{minted}

\subsubsection{关键字参数}
函数可以通过关键字参数的形式来调用，形如 keyword = value。例如，以下的函数：
\begin{minted}{python}
>>> def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
...     print("-- This parrot wouldn't", action, end=' ')
...     print("if you put", voltage, "volts through it.")
...     print("-- Lovely plumage, the", type)
...     print("-- It's", state, "!")
\end{minted}

接受一个必选参数（voltage）以及三个可选参数（state, action和type）。可以用以下的任一方法调用：
\begin{minted}{python}
>>> parrot(1000)                      # 1 positional argument
-- This parrot wouldn't voom if you put 1000 volts through it.
-- Lovely plumage, the Norwegian Blue
-- It's a stiff !
>>> parrot(voltage=1000)              # 1 keyword argument
-- This parrot wouldn't voom if you put 1000 volts through it.
-- Lovely plumage, the Norwegian Blue
-- It's a stiff !
>>> parrot(voltage=1000000, action='VOOOOOM')  # 2 keyword arguments
-- This parrot wouldn't VOOOOOM if you put 1000000 volts through it.
-- Lovely plumage, the Norwegian Blue
-- It's a stiff !
>>> parrot(action='VOOOOOM',voltage=1000000)   # 2 keyword arguments
-- This parrot wouldn't VOOOOOM if you put 1000000 volts through it.
-- Lovely plumage, the Norwegian Blue
-- It's a stiff !
>>> parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword
-- This parrot wouldn't voom if you put a thousand volts through it.
-- Lovely plumage, the Norwegian Blue
-- It's pushing up the daisies !
\end{minted}

不过以下几种调用是无效的：
\begin{minted}{python}
>>> parrot()                     # requried argument missing
>>> parrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword argument
>>> parrot(110, voltage=220)     # duplicate value for the same argument
>>> parrot(actor='John Cleese')  # unknow keyword argument
\end{minted}

在函数调用中，关键字的参数必须跟随在位置参数的后面。传递的所有关键字参数必须与函数接受的某个参数相匹配
（例如 actor 不是 parrot 函数的有效参数），它们的顺序并不重要。这也包括非可选参数（例如 parrot(voltage=100)也是有效的）。
任何参数都不可以多次赋值。下面的示例由于这种限制将失败:
\begin{minted}{python}
>>> def function(a):
...     pass
...
>>> function(0, a=0)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: function() got multiple values for argument 'a'
\end{minted}

引入一个形如 $**$name 的参数时，它接收一个字典（参见Mapping Types-dict）,该字典包含了所有未出现在形式参数列表中的关键字参数。
这里可能还会组合使用一个形如 $*$name （下一小节详细介绍）的形式参数，它接收一个元组（下一节中会详细介绍），包含了所有没有出现在形式参数
列表中的参数值（ $*$name必须在 $**$name之前出现）。例如，我们这样定义一个函数：
\begin{minted}{python}
>>> def cheeseshop(kind, *arguments, **keywords):
...     print("-- Do you have any", kind, "?")
...     print("-- I'm sorry. we're all out of", kind)
...     for arg in arguments:
...             print(arg)
...     print("-" * 40)
...     keys = sorted(keywords.keys())
...     for kw in keys:
...             print(kw, ":", keywords[kw])
\end{minted}

它可以像这样调用：
\begin{minted}{python}
>>> cheeseshop("Limburger", "It's very runny, sir.",
...             "It's really very, VERY runny, sir.",
...             shopkeeper="Michael Palin."
...             client="John Cleese",
...             sketch="Cheese Shop Sketch")
\end{minted}

当然它会按如下内容打印：
\begin{minted}{python}
-- Do you have any Limburger ?
-- I'm sorry, we're all out of Limburger
It's very runny, sir.
It's really very, VERY runny, sir.
----------------------------------------
client : John Cleese
shopkeeper : Michael Palin
sketch : Cheese Shop Sketch
\end{minted}

注意在打印关键字参数之前，通过对关键字字典 keys() 方法的结果进行排序，生成了关键字参数名的列表；
如果不这样做，打印出来的参数顺序是未定义的。

\subsubsection{可变参数列表}
最后，一个最不常用的选择是可以让函数调用可变个数的参数。这些参数被包装进一个元祖（参见 元祖和序列）。
在这个可变个数的参数之前，可以有零到多个普通的参数：
\begin{minted}{python}
>>> def concat(*args, sep="/"):
...     return sep.join(args)
...
>>> concat("earth", "mars", "venus")
'earth/mars/venus'
>>> concat("earth", "mars", "venus", sep=".")
'earth.mars.venus'
\end{minted}
\subsubsection{参数列表的拆分}
另一种相反的情况：当你要传递的参数已经是一个列表，但要调用的函数却接受分开一个个的参数值。
这时候你要把已有的列表拆开来。例如内建函数 range()需要要独立的 start, stop参数。
你可以在调用函数时加一个$*$操作符来自动把参数列表拆开：
\begin{minted}{python}
>>> list(range(3, 6))   # normal call with separate arguments
[3, 4, 5]
>>> args = [3, 6]
>>> list(range(*args))  # call with arguments unpacked from a list
[3, 4, 5]
\end{minted}

以同样的方法，可以使用$**$操作符拆分关键字参数为字典：
\begin{minted}{python}
>>> def parrot(voltage, state='a stiff', action='voom'):
...     print("-- This parrto wouldn't", action, end=' ')
...     print("if you put", voltage, "volts through it.", end=' ')
...     print("E's", state, "!")
...
>>> d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
>>> parrot(**d)
-- This parrto wouldn't VOOM if you put four million volts through it. E's bleedin' demised !
\end{minted}

\subsubsection{Lambda形式}
出于实际需要，有几种通常在函数式编程语言例如Lisp中出现的功能加入到了Python。通过lambda关键字，
可以创建短小的匿名函数。这里有一个函数返回它的两个参数的和：lambda a, b: a+b。Lambda形式可以用于任何
需要的函数对象。出于语法限制，它们只能有一个单独的表达式。
\begin{minted}{python}
>>> def make_incrementor(n):
...     return lambda x: x + n
...
>>> f = make_incrementor(42)
>>> f(0)
42
>>> f(1)
43
\end{minted}

上面的示例使用lambda表达式返回一个函数。另一个用途是将一个小函数作为参数传递：
\begin{minted}{python}
>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
>>> pairs.sort(key=lambda pair: pair[1])
>>> pairs
[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]
\end{minted}

\subsubsection{文档字符串}
这里介绍的文档字符串的概念和格式。

第一行应该是关于对象用途的简介。简短起见，不用明确的陈述对象名或类型，
因为它们可以从别的途径了解到（除非这个名字碰巧就是描述这个函数操作的动词）。这一行应该
以大写字母开头，以句号结尾。

如果文档字符串有多行，第二行应该空出来，与接下俩的详细描述明确分隔。接下来的文档婴孩有一
或多段描述对象的调用约定、边界效应等。

Python的解释器不会从多行的文档字符串中取除缩进，所以必要的时候应当自己清除缩进。这符合通常的习惯。
第一行之后的第一个非空行决定了整个文档的缩进格式。（我们不用第一行是因为它通常紧靠着起始的引号，缩进
的话，所有的留白都应该清除掉。留白的长度应当等于扩展制表符的宽度（通常是8个空格）。

以下是一个多行文档字符串的示例：
\begin{minted}{python}
>>> def my_function():
...     """Do nothing, but document it.
...
...     No, really, it doesn't do anything.
...     """
...     pass
...
>>> print(my_function.__doc__)
Do nothing, but document it.

	No, really, it doesn't do anything.
\end{minted}

\section{数据结构}
\subsection{关于列表的更多的内容}
Python的列表数据类型包含更多的方法。这里是所有的列表对象方法：
\begin{itemize}
  \item list.append(x) 把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]
  \item list.extend(L) 将一个给定列表中的所有元素都添加到另一个列表中，相当于 a[len(a):]=L
  \item list.insert(i,x) 在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，
  例如 a.insert(0, x)会插入到整个列表之前，而 a.insert(len(a), x)相当于 a.append(x)。
  \item list.remove(x) 删除列表中值为x的第一个元素。如果没有这样的元素，就会返回一个错误。
  \item list.pop([i]) 从列表的指定位置删除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。
  元素随机从列表中被删除（方法中i两边的方括号表示这个参数是可选的，而不是要求你的输入一对方括号，你会经常
  在Python库参考手册中遇到这样的标记）。
  \item list.clear() 从列表中删除所有元素。相当于 del a[:]。
  \item list.count(x) 返回x在列表中出现的次数
  \item list.index(x) 返回列表中第一个值为x的元素的索引。如果没有匹配的元素就会返回一个错误。
  \item list.sort() 对类表中的元素就地进行排列。
  \item list.reverse() 就地倒排列表中的元素。
  \item list.copy() 返回列表的一个浅拷贝。等同于 a[:]。
\end{itemize}

下面这个示例演示了列表的大部分方法：
\begin{minted}{python}
>>> a = [66.25, 333, 333, 1, 1234.5]
>>> print(a.count(333), a.count(66.25), a.count('x'))
2 1 0
>>> a.insert(2, -1)
>>> a.append(333)
>>> a
[66.25, 333, -1, 333, 1, 1234.5, 333]
>>> a.index(333)
1
>>> a.remove(333)
>>> a
[66.25, -1, 333, 1, 1234.5, 333]
>>> a.reverse()
>>> a
[333, 1234.5, 1, 333, -1, 66.25]
>>> a.sort()
>>> a
[-1, 1, 66.25, 333, 333, 1234.5]
>>> a.pop()
1234.5
>>> a
[-1, 1, 66.25, 333, 333]
\end{minted}

也许大家会发现像insert, remove 或者sort这些修改列表的方法没有打印返回值——它们
返回None。在python中对所有可变的数据类型这是统一的设计原则。
\subsubsection{把列表当作堆栈使用}
列表方法使得列表可以很方便的作为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素
最后一个被释放（后进先出）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的
 pop() 方法可以把一个元素从堆栈顶释放出来。例如：
 \begin{minted}{python}
 >>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack.append(7)
>>> stack
[3, 4, 5, 6, 7]
>>> stack.pop()
7
>>> stack
[3, 4, 5, 6]
>>> stack.pop()
6
>>> stack.pop()
5
>>> stack
[3, 4]
\end{minted}
\subsubsection{把列表当做队列使用}
你也可以把列表当做队列使用，队列作为特定的数据结构，最先进入的元素最先释放（先进先出）。
不过，列表这样用效率不高。相对来说从列表末尾添加和弹出很快；在头部插入和弹出很慢（因为，
为了一个元素，要移动整个列表中的所有元素）。

要实现队列，使用 collections.deque,它为在首尾两端快速插入和删除而设计。例如：
\begin{minted}{python}
>>> from collections import deque
>>> queue = deque(["Eric", "John", "Michael"])
>>> queue.append("Terry")               # Terry arrives
>>> queue.append("Graham")              # Graham arrives
>>> queue.popleft()                     # The first to arrive now leaves
'Eric'
>>> queue.popleft()                     # The second to arrive now leaves
'John'
>>> queue                               # Remaining queue in order of arrival
deque(['Michael', 'Terry', 'Graham'])
\end{minted}
\subsubsection{列表推导式}
列表推导式为从序列中创建列表提供了一个简单的方法。普通的应用程式通过将一些操作应用于
序列的每个成员并通过返回的元素创建列表，或者通过满足特定条件的元素创建子序列。
\begin{minted}{python}
>>> squares = []
>>> for x in range(10):
...     squares.append(x**2)
...
>>> squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
\end{minted}

注意这个for循环中的被创建（或被重写）的名为x的变量在循环完毕后依然存在。使用如下方法，我们可以计算
squares的值而不会产生任何的副作用：
\begin{minted}{python}
>>> squares = list(map(lambda x: x**2, range(10)))
\end{minted}

或者等价于：
\begin{minted}{python}
squares = [x**2 for x in range(10)]
\end{minted}

上面这个方法更加简明且易读。

列表推导式由包含一个表达式的括号组成，表达式后面跟随一个for子句，之后可以有零个或多个for或if子句。
结果是一个列表，由表达式依据其后面的for和if子句上下文计算而来的结果构成。

例如，如下的列表推导式结合两个列表的元素，如果两个元素之间不相等的话：
\begin{minted}{python}
>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x !=y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
\end{minted}

等同于：
\begin{minted}{python}
>>> combs = []
>>> for x in [1,2,3]:
...     for y in [3,1,4]:
...             if x != y:
...                     combs.append((x,y))
...
>>> combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
\end{minted}

值得注意的是在上面两个方法中的for和if语句的顺序。

如果想要得到一个元组（例如，上面例子中的（x，y)），必须要加上括号：
\begin{minted}{python}
>>> vec = [-4, -2, 0, 2, 4]
>>> # create a new list with the values doubled
>>>[x*2 for x in vec]
[-8, -4, 0, 4, 8]
>>> # filter the list to exclude negative numbers
>>> [x for x in vec if x >= 0]
[0, 2, 4]
>>> # apply a function to all the elements
>>> [abs(x) for x in vec]
[4, 2, 0, 2, 4]
>>> # call a method on each elements
>>> freshfruit = [' banana', ' loganberry', 'passion fruit ']
>>> [weapon.strip() for weapon in freshfruit]
['banana', 'loganberry', 'passion fruit']
>>> # create a list of 2-tuples like (number, square)
>>> [(x, x**2) for x in range(6)]
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
>>> # the tuple must be parenthesized, otherwise an error is raised
>>> [x, x**2 for x in range(6)]
  File "<stdin>", line 1
    [x, x**2 for x in range(6)]
               ^
SyntaxError: invalid syntax
>>> # flatten a list using a listcomp with two 'for'
>>> vec = [[1,2,3], [4,5,6], [7,8,9]]
>>> [num for elem in vec for num in elem]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{minted}

列表推导式可使用复杂的表达式和嵌套函数：
\begin{minted}{python}
>>> from math import pi
>>> [str(round(pi, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
\end{minted}
\subsubsection{嵌套的列表推导式}
列表解析中的第一个表达式可以是任何表达式，包括列表解析。

考虑下面由三个长度为4的列表组成3$\times$4矩阵：
\begin{minted}{python}
>>> matrix = [
...     [1, 2, 3, 4],
...     [5, 6, 7, 8],
...     [9, 10, 11, 12],
... ]
\end{minted}

现在如果你想交换行和列，可以用嵌套的列表推导式：
\begin{minted}{python}
>>> [[row[i] for row in matrix] for i in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
\end{minted}

像前面看到的，嵌套的列表推导式是对for后面的内容进行求值，所以上例就等价于：
\begin{minted}{python}
>>> transposed = []
>>> for i in range(4):
...     # the following 3 lines implement the nested listcomp
...     transposed_row = []
...     for row in matrix:
...             transposed_row.append(row[i])
...     transposed.append(transposed_row)
...
>>> tramsposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
\end{minted}

在实际中，你应该更喜欢使用内置函数组成复杂流程语句。对这种情况 zip()函数将会做的更好：
\begin{minted}{python}
>>> list(zip(*matrix))
[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
\end{minted}

更多关于本行中使用的星号的说明，参考 参数列表的拆分。
\subsection{del语句}
有个方法可以从类表中按给定的索引而不是值来删除一个子项：del语句。它不同于有返回值的
pop()方法。语句del还可以从列表中删除切片或清空整个列表（我们以前介绍过一个方法是将空列表
赋值给列表的切片）。例如：
\begin{minted}{python}
>>> a = [-1, 1, 66.25, 333, 333, 1234.5]
>>> del a[0]
>>> a
[1, 66.25, 333, 333, 1234.5]
>>> del a[2:4]
>>> a
[1, 66.25, 1234.5]
>>> del a[:]
>>> a
[]
\end{minted}

del也可以删除整个变量：
\begin{minted}{python}
>>> del a
>>> a
\end{minted}

此后再引用命名a会引发错误（直到另一个值赋给它为止）。我们在后面的内容中可以看到del的其它用法。
\subsection{元组和序列}
我们知道列表和字符串有很多通用的属性，例如索引和切割操作。它们是序列类型（参见Sequence Types -
list,tuple,range) 中的两种。因为Python是一个在不停进化的语言，也可能会加入其它的序列类型，这里
介绍另一种标准序列类型：元组。

一个元组由数个逗号分隔的值组成，例如：
\begin{minted}{python}
>>> t = 12345, 54321, 'hello!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hello!')
>>> # Tuples may be nested:
... u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
>>> # Tuples are immutable:
... t[0] = 88888
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
TypeError: 'tuple' object does not support item assignment
>>> # but they can contain mutable objects:
... v = ([1, 2, 3], [3, 2, 1])
>>> v
([1, 2, 3], [3, 2, 1])
\end{minted}
正如你所见，元组在输出时总是有括号的，以便于正确表达嵌套结构。在输入时
可以有或没有括号，不过经常括号都是必须的（如果元组是一个更大的表达式的一部分）。
不能给元组的一个独立的元素赋值（尽管你可以通过联接和切割来模拟）。还可以创建包含可变
对象的元组，例如列表。

虽然元组和列表很类似，它们经常被用来在不同的情况和不同的用途。元组有很多用途。例如（x,y）
坐标对，数据库中的员工记录等等。元组就像字符串，不可变的。通常包含不同种类的元素并通过分拆（参阅
本节后面的内容）或索引访问（如果是namedtuples,甚至可以通过属性）。列表是可变的，它们的元素通常是相同类型的并通过迭代访问。

一个特殊的问题是构造包含零个或一个元素的元组：为了适应这种情况，语法上有一些额外的改变。一对空的括号可以创建空元组；
要创建一个单元素元组可以在值后面跟一个逗号（在括号中放入一个单值不够明确）。丑陋，但是有效。例如：
\begin{minted}{python}
>>> empty = ()
>>> singleton = 'hello',     # <-- note trailing comma
>>> len(empty)
0
>>> len(singleton)
1
>>> singleton
('hello',)
\end{minted}

语句 t = 12345, 54321, `hello!' 是元组封装（tuple packing）的一个例子：值12345，54321和`hello'
被封装进元组。其逆操作可能是这样：
\begin{minted}{python}
>>> x, y, z = t
\end{minted}

这个调用等号右边可以是任何线性序列，称之为序列拆分非常恰当。序列拆封要企业左侧的变量数目与序列的元素个数相同。要
注意的是可变参数（multiple assignment)其实只是元组封装的序列拆封的一个结合。

\subsection{集合}
Python还包含了一个数据类型--set（集合）。集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。集合对象还支持
union（联合），intersection（交），difference（差）和sysmmetric difference（对称差集）等数学运算。

大括号或 set() 函数可以用来创建集合。注意：想要创建空集合，你必须要使用 set() 而不是 {}。
后者用于创建空字典。以下是一个简单的演示：
\begin{minted}{python}
>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
>>> print(basket)                     # show that duplicates have been removed
{'pear', 'apple', 'orange', 'banana'}
>>> 'orange' in basket                 # fast membership testing
True
>>> 'crabgrass' in basket
False
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                      # unique letters in a
{'r', 'a', 'd', 'c', 'b'}
>>> a - b                  # letters in a but not in b
{'d', 'r', 'b'}
>>> a | b                  # letters in either a or b
{'r', 'a', 'l', 'd', 'c', 'z', 'm', 'b'}
>>> a & b                  # letters in both a and b
{'a', 'c'}
>>> a ^ b                  # letters in a or b but not both
{'r', 'l', 'z', 'd', 'm', 'b'}
\end{minted}

类似列表推导式，这里有一种集合推导式语法：
\begin{minted}{python}
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'d', 'r'}
\end{minted}

\subsection{字典}
另一个非常有用的Python内建数据类型 是字典（参见Mapping Types - dict）。字典在
某些语言中可能称为 联合内存（associative memories）或联合数组（associative arrays）。
序列是以连续的整数为索引，与此不同的是，字典以关键字为索引，关键字可以是任意不可变类型，通常用字符串或数值。
如果元组中只包含字符串和数字，他可以作为关键字，如果它直接或间接的包含了可变对象，就不能当做
关键字。不能用列表做关键字，因为列表可以用索引、切割或者appen()和extend()等方法改变。

理解字典的最佳方式是把它看做无序的键：值对（key:value对）集合，键必须是互不相同的（在同一个字典之内）。
一对大括号创建一个空的字典： {} 。初始化列表时，在大括号内放置一组逗号分隔的键：值对，这也是字典输出的方式。

字典的主要操作是依据键来存储和析取值。也可以用 del 来删除键：值对（key:value）。如果你用一个已经存在的关键字
存储值，以前为该关键字分配的值就会被遗忘。试图从一个不存在的键中取值会导致错误。

对一个字典执行 list(d.keys()) 将返回一个字典中所有关键字组成的无序列表（如果你想要排序，只需使用 sorted(d.key())
使用 in 关键字（指Python语法）可以检查字典中是否存在某个关键字（指字典）。

字典示例：
\begin{minted}{python}
>>> tel = {'jack': 4098, 'sape': 4139}
>>> tel['guido'] = 4127
>>> tel
{'jack': 4098, 'sape': 4139, 'guido': 4127}
>>> tel['jack']
4098
>>> del tel['sape']
>>> tel['irv'] = 4127
>>> tel
{'jack': 4098, 'guido': 4127, 'irv': 4127}
>>> 'guido' in tel
True
>>> 'jack' not in tel
False
\end{minted}

dict()构造函数可以直接从key-value对中创建字典：
\begin{minted}{python}
>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'guido': 4127, 'jack': 4098}
\end{minted}

此外，字典推导可以从任意的键值表达式中创建字典：
\begin{minted}{python}
>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
\end{minted}

如果关键字都是简单的字符串，有时通过关键字参数指定 key-value 对更为方便：
\begin{minted}{python}
>>> dict(sape=4139, guido=4127, jack=4098)
{'sape': 4139, 'guido': 4127, 'jack': 4098}
\end{minted}

\subsection{循环技巧}
在字典中循环时，关键字和对应的值可以使用 items() 方法同时解读出来：
\begin{minted}{python}
>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
>>> for k,v in knights.items():
...     print(k, v)
...
gallahad the pure
robin the brave
\end{minted}

在序列中循环时，索引位置和对应值可以使用 enumerate() 函数同时得到：
\begin{minted}{python}
>>> for i, v in enumerate(['tic', 'tac', 'toe']):
...     print(i, v)
...
0 tic
1 tac
2 toe
\end{minted}

同时循环两个或更多的序列，可以使用 zip() 整体打包：
\begin{minted}{python}
>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> for q, a in zip(questions, answers):
...     print('What is your {0}? It is {1}.' .format(q, a))
...
What is your name ? It is lancelot.
What is your quest ? It is the holy grail.
What is your favorite color ? It is blue.
\end{minted}

需要逆向循环序列的话，先正向定位序列，然后调用 reversed() 函数：
\begin{minted}{python}
>>> for i in reversed(range(1, 10, 2)):
...     print(i)
...
9
7
5
3
1
\end{minted}

要按排序后的顺序循环序列的话，使用sorted()函数，他不改动原序列，而是生成一个新的已排序的序列：
\begin{minted}{python}
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for f in sorted(set(basket)):
...     print(f)
...
apple
banana
orange
pear
\end{minted}

若要在循环内部修改正在遍历的序列（例如复制某些元素），建议您首先制作副本。在序列上循环不会隐式地创建
副本。切片表示法使用这尤其方便：
\begin{minted}{python}
>>> words = ['cat', 'window', 'defenstrate']
>>> for w in words[:]:      # Loop over a slice copy of the entire list.
...     if len(w) > 6:
...             words.insert(0, w)
...
>>> words
['defenstrate', 'cat', 'window', 'defenstrate']
\end{minted}

\subsection{深入条件控制}
while 和 if 语句中使用的条件不仅可以使用比较，而且可以包含任意的操作。

比较操作符 in 和 not in 审核值是否在一个区间之内。操作符 is 和 is not 比较两个对象时否相同；
这只和诸如列表这样的可变对象有关。所有的比较操作符具有相同的优先级，低于所有的数值操作。

比较操作可以传递。例如 a < b == c 审核是否 a 小于 b 并且 b 等于 c。

比较操作可以通过逻辑操作符 and 和 or 组合，比较的结果可以用 not 来取反义。这些操作符的优先级又低于比较操作符，
在他们之中， not 具有最高的优先级，or 优先级最低，所以A and not B or C 等于（A and (notB)) or C。当然，括号也可以
用于比较表达式。

逻辑操作符 and 和 or 也称为短路操作符：它们的参数从左向右解析，一旦结果可以确定就停止。例如，如果 A 和 C 为真而
B 为假，A and B and C 不会解析C。作用于一个普通的非逻辑值时，短路操作符的返回值通常是最后一个变量。

可以把比较或其它逻辑表达式的返回值赋给一个变量，例如：
\begin{minted}{python}
>>> string1, string2, string3 = '', 'Tronheim', 'Hammer Dance'
>>> non_null = string1 or string2 or string3
>>> non_null
'Tronheim'
\end{minted}

需要注意的是Python与C不同，在表达式内部不能赋值。C程序员经常对此抱怨，不过它避免了一类在C程序中司空见惯的错误：想要在解析式中使用==时误用了=操作符。

\subsection{比较序列和其它类型}
序列对像可以与相同类型的其它对象比较。比较操作按字典序进行：首先比较前两个元素，如果不同，就决定了比较的结果；
如果相同，就比较后两个元素，依此类推，直到所有序列都完成比较。如果两个元素本身就是同样类型的序列，就递归字典序比较。如果两个序列的所有子项都相等，就
认为序列相等。如果一个序列是另一个序列的初始子序列，较短的一个序列就小于另一个。字符串的字典序按照单字符的ASCII顺序。下面是同类型序列之间比较的一些例子：
\begin{minted}{python}
>>> (1, 2, 3)           < (1, 2, 4)
True
>>> [1, 2, 3]           < [1, 2, 4]
True
>>> 'ABC' < 'C' < 'Pascal' < 'Python'
True
>>> (1, 2, 3, 4)        < (1, 2, 4)
True
>>> (1, 2)              < (1, 2, -1)
True
>>> (1, 2, 3)           < (1.0, 2.0, 3.0)
False
>>> (1, 2, ('aa', 'ab'))        <(1, 2, ('abc', 'a'), 4)
True
\end{minted}

需要注意的是如果通过 $<$ 或者 $>$ 比较的对象只要具有合适的比较方法就是合法的。比如，混合数值类型是通过它们
的数值进行比较的，所以0等于0.0。否则解释器将会触发一个TypeError异常，而不是提供以和随意的结果。

\section{模块}
如果你退出Python解释器并重新进入，你做的任何定义（变量和方法）都会丢失。因此，如果你想要编写一些更大的程序，
为准备解释器输入使用一个文本编辑器会更好，并以那个文件替代作为输入执行。这就是传说中的脚本。随着你的程序变得越来越长，你可能想要将它
分割成几个更易于维护的文件。你也可能想在不同的程序中使用顺手的函数，而不是把代码在它们之间中考来拷去。

为了满足这些需要，Python提供了一个方法可以从文件中获取定义，在脚本或者解释器的一个交互式实例中使用。这样的文件被称为
模块；模块中的定义可以导入到另一个模块或主模块中（在脚本执行时可以调用的变量集位于最高级，并且处于计算器模式）。

模块是包括Python定义和声明的文件。文件名就是模块名加上 .py 后缀。模块的模块名（做为一个字符串）可以由全局变量
\_\_name\_\_ 得到。例如，你可以用自己惯用的文件编辑器在当前目录下创建一个叫 fibo.py 的文件，录入如下内容：
\begin{minted}{python}
# Fibonacci numbers module

def fib(n):        # write Fibonacci series up to n
    a, b = 0, 1
    while b < n:
        print(b, end=' ')
        a, b = b, a+b
    print()

def fib2(n):        # return Fibonacci series up to n
    result = []
    a, b = 0, 1
    while b < n:
        result.append(b)
        a, b = b, a+b
    return result
\end{minted}

现在进入Python解释器并使用以下命令导入模块：
\begin{minted}{python}
>>> import fibo
\end{minted}

这样做不会直接把 fibo 中的函数导入当前的语义表；它只是引入了模块名 fibo。你可以通过模块名按
如下方式访问这个函数：
\begin{minted}{python}
>>> fibo.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
>>> fibo.fib(100)
1 1 2 3 5 8 13 21 34 55 89
>>> fibo.__name__
'fibo'
\end{minted}

如果打算频繁使用一个函数，你可以将它赋予一个本地变量：
\begin{minted}{python}
>>> fib = fibo.fib
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
\end{minted}

\subsection{深入模块}
除了包含函数定义外，模块也可以包含执行语句。这些语句一般用来初始化模块。他们仅在第一次被导入的地方执行一次。

每个模块都有自己私有的符号表，被模块内所有的函数定义作为全局符号使用。因此，模块的作者可以在模块内部使用全局变量，
而无需担心它与某个用户的全局变量意外冲突。从另一个方面讲，如果你确切的知道自己在做什么，你可以使用引用模块函数的表示法
访问模块的全局变量， modname.itemname。

模块可以导入其他的模块。一个（好的）习惯是将所以的 import 语句放在模块的开始（或者是脚本），这并非强制。被导入命名到
本模块的语义表中。

import 语句的一个变体直接从被导入的模块中导入命名到本模块的语义表中。例如：
\begin{minted}{python}
>>> from fibo import fib, fib2
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
\end{minted}

这样不会从局域语义表中导入模块名（如上所示，fibo 没有定义）。

甚至有种方式可以导入模块中的所有定义：
\begin{minted}{python}
>>> from fibo import *
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
\end{minted}

这样可以导入所有除了以下划线（\_）开头的命名。

需要注意的是在实践中往往不鼓励从一个模块或包中使用\*导入所有，因为这样会让代码变得很难读。不过，在交互式会话中这样用很方便省力。

注意：出于性能考虑，每个模块在每个解释器会话中只导入一遍。因此，如果你修改了你的模块，需要重启解释器；或者，如果你就是想
交互式的测试这么一个模块，可以用imp.reload()重新加载，例如： import imp: imp.reload(modulename)。

\subsubsection{作为脚本来执行模块}
当你使用以下方式运行Python模块时，模块中的代码便会被执行：
\begin{minted}{python}
>>> python fibo.py <arguments>
\end{minted}

模块中的代码会被执行，就像导入它一样，不过此时 \_\_name\_\_ 被设置为 ``\_\_main\_\_''。这相当于，
如果你在模块后加入代码：
\begin{minted}{python}
if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))
\end{minted}

就可以让文件像作为模块导入时一样作为脚本执行。此代码只有在模块作为``mian''文件执行时才被调用：
\begin{minted}{python}
lujingyu $ python fibo.py 50
1 1 2 3 5 8 13 21 34
\end{minted}

如果模块被导入，不会执行这段代码：
\begin{minted}{python}
>>> import fibo
>>>
\end{minted}

这通常用来为模块提供一个便于测试的用户接口（将模块作为脚本执行测试需求）。

\subsubsection{模块的搜索路径}
导入一个叫 spam 的模块时，解释器先在当前目录中搜索名为 spam.py 的文件。
如果没有找到的话，接着会到sys.path变量中给出的目录列表中查找。sys.path变量的初始化值来自如下：
\begin{itemize}
  \item 输入脚本的目录（当前目录）。
  \item 环境变量PYTHONPATH表示的目录列表中搜索（这和shell变量PATH具有一样的语法，即一系列目录名的列表）。
  \item Python 默认安装路径中搜索。
\end{itemize}

注释：在支持符号连接的文件系统中，输入的脚本所在的目录是符号链接指向的目录。换句话说也就是包含符号链接的目录不会
被加到目录搜索路径中。

实际上解释器由sys.path变量指定的路径目录搜索模块，该变量初始化时默认包含了输入脚本（或者当前目录），
PYTHONPATH和安装目录。这样就允许Python程序了解如何修改或替换模块搜索目录。需要注意的是由于这些目录中包含有搜索路径中运行的脚本，
所以这些脚本不应该和标准模块重名，否则在导入模块时Python会尝试把这些脚本当做模块来加载。这通常会引发错误。

\subsubsection{"编译的"Python文件}
为了加快加载模块的速度，Python 会在 \_\_pycache\_\_ 目录下以 module.version.pyc 名字缓存每个模块编译后的版本，
这里的版本编制了编译后文件的格式。它通常会包含 Python 的版本号。例如，在 CPython 3.3 版中，
spam.py 编译后的版本将缓存为 \_\_pycache\_\_\/spam.cpython\-33.pyc。
这种命名约定允许由不同发布和不同版本的 Python 编译的模块同时存在。

Python 会检查源文件与编译版的修改日期以确定它是否过期并需要重新编译。
这是完全自动化的过程。同时，编译后的模块是跨平台的，所以同一个库可以在不同架构的系统之间共享。

Python 不检查在两个不同环境中的缓存。首先，它会永远重新编译而且不会存储直接从命令行加载的模块。
其次，如果没有源模块它不会检查缓存。若要支持没有源文件（只有编译版）的发布，
编译后的模块必须在源目录下，并且必须没有源文件的模块。

部分高级技巧:
\begin{itemize}
  \item 为了减少一个编译模块的大小，你可以在Python命令行中使用 \-O 或者 \-OO。\-O参数删除了断言语句，
  \-OO参数删除了断言语句和\_\_doc\_\_字符串。

  因为某些程序依赖因为某些程序依赖于这些变量的可用性，你应该只在确定无误的场合使用这一选项。
  “优化的” 模块有一个 .pyo 后缀而不是 .pyc 后缀。未来的版本可能会改变优化的效果。
  \item 来自 .pyc 文件或 .pyo 文件中的程序不会比来自 .py 文件的运行更快；.pyc 或 .pyo 文件只是在它们加载的时候更快一些。
  \item compileall 模块可以为指定目录中的所有模块创建 .pyc 文件（或者使用 -O 参数创建 .pyo 文件）。
\end{itemize}

\subsection{标准模块}
Python带有一个标准模块库，并发布由独立的文档，名为Python库参考手册（此后称其为``库参考手册''）。
有一些模块内置于解释器之中，这些操作的访问接口不是语言内核的一部分，但是已经内置于解释器了。这既是为了提高效率
，也是为了给系统调用等操作系统原生访问提供接口。这类模块集合是一个依赖于底层平台的配置选项。
例如，winreg模块只提供在Windows系统上才有。有一个具体的模块值得注意：sys，这个模块内置于所有的Python
解释器。变量sys.ps1和sys.ps2定义可主提示符和辅助提示符字符串：
\begin{minted}{python}
>>> import sys
>>> sys.ps1
'>>> '
>>> sys.ps2
'... '
>>> sys.ps1 = 'C>'
C> print('Yuck!')
Yuck!
C>
\end{minted}

这两个变量只在解释器的交互模式下有意义。

变量sys.path是解释器模块搜索路径的字符串列表。它由环境变量PYTHONPATH 初始化，
如果没有设定 PYTHONPATH ，就由内置的默认值初始化。你可以用标准的字符串操作修改它:
\begin{minted}{python}
>>> import sys
>>> sys.path.append('ufs/guido/lib/python')
\end{minted}
\subsection{dir()函数}
内置函数dir()用于按模块名搜索块定义，它返回一个字符串类型的存储列表：
\begin{minted}{python}
>>> import fibo, sys
>>> dir(fibo)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__',

'__package__', '__spec__', 'fib', 'fib2']
>>> dir(sys)
['__displayhook__', '__doc__', '__excepthook__', '__interactivehook__', '__loader__',

'__name__', '__package__','__spec__', '__stderr__', '__stdin__', '__stdout__',

'_clear_type_cache', '_current_frames', '_debugmallocstats', '_getframe',

'_git', '_home', '_xoptions', 'abiflags', 'api_version', 'argv', 'base_exec_prefix',

'base_prefix', 'builtin_module_names', 'byteorder','call_tracing', 'callstats',

'copyright', 'displayhook', 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix',

'executable', 'exit','flags', 'float_info', 'float_repr_style', 'get_asyncgen_hooks',

'get_coroutine_wrapper', 'getallocatedblocks', 'getcheckinterval','getdefaultencoding',

 'getdlopenflags', 'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile',

 'getrecursionlimit', 'getrefcount','getsizeof', 'getswitchinterval', 'gettrace',

 'hash_info', 'hexversion', 'implementation', 'int_info', 'intern', 'is_finalizing', 'maxsize',

'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache', 'platform',

 'prefix', 'ps1', 'ps2', 'set_asyncgen_hooks','set_coroutine_wrapper', 'setcheckinterval',

 'setdlopenflags', 'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr',

'stdin', 'stdout', 'thread_info', 'version', 'version_info', 'warnoptions']
\end{minted}

无参调用时，dir()函数返回当前定义的命名：
\begin{minted}{python}
>>> a = [1, 2, 3, 4, 5]
>>> import fibo
>>> fib = fibo.fib
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__',

'__name__', '__package__', '__spec__', 'a', 'fib', 'fibo', 'sys']
\end{minted}

注意该列表列出了所有类型的名称：变量，模块，函数，等等。

dir()不会列出内置函数和变量名。如果你想列出这些内容，它们在标准模块builtins中定义：
\begin{minted}{python}
>>> import builtins
>>> dir(builtins)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError',

'BrokenPipeError', 'BufferError','BytesWarning', 'ChildProcessError', 'ConnectionAbortedError',

'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError','DeprecationWarning',

'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError',

'FileNotFoundError','FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError',

'ImportError', 'ImportWarning','IndentationError', 'IndexError','InterruptedError',

'IsADirectoryError', 'KeyError', 'KeyboardInterrupt','LookupError', 'MemoryError',

'ModuleNotFoundError', 'NameError','None', 'NotADirectoryError','NotImplemented',

'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning',

'PermissionError','ProcessLookupError', 'RecursionError', 'ReferenceError',

'ResourceWarning', 'RuntimeError', 'RuntimeWarning','StopAsyncIteration', 'StopIteration',

'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit','TabError', 'TimeoutError',

'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError','UnicodeEncodeError',

'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError',

'Warning', 'ZeroDivisionError', '_','__build_class__', '__debug__', '__doc__',

'__import__', '__loader__', '__name__', '__package__', '__spec__','abs', 'all', 'any',

'ascii', 'bin','bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod',

'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod',

'enumerate', 'eval','exec', 'exit', 'filter', 'float', 'format', 'frozenset',

'getattr', 'globals', 'hasattr', 'hash','help', 'hex', 'id','input', 'int',

'isinstance', 'issubclass', 'iter', 'len', 'license', 'list','locals', 'map',

'max', 'memoryview', 'min', 'next', 'object','oct', 'open', 'ord', 'pow',

'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr',

'slice', 'sorted','staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']
\end{minted}

\subsection{包}
包通常是使用用"圆点模块名"的结构化模块命名空间。例如，名为 A.B的模块表示了名为A的包中名为B的子块。正如同用
模块来保存不同的模块架构可以避免全局变量之间的相互冲突，使用圆点模块名保存像 NumPy 或 Python Imaging Library
之类的 不同类库架构可以避免模块之间的明明冲突。

假设你现在想要设计一个模块集（一个``包''）来统一处理声音文件和声音数据。存在几种不同的声音格式
（通常由他们的扩展名来标识，例如：.wav, .aiff, .au），于是，为了在不同类型的文件格式之间转换，你需要维护一个不断增长
的包集合。可能你还想要对声音数据做很多不同的操作（例如混音，添加回声，应用平衡 功能，创建一个人造效果），
所以你要加入一个无限流模块来执行这些操作。你的包可能会是这个样子（通过分级的文件体系来进行分组）:
\begin{minted}{python}
sound/                          Top-level package
      __init__.py               Initialize the sound package
      formats/                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Subpackage for sound effects
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Subpackage for filters
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
\end{minted}

当导入这个包时，Python 通过 sys.path搜索路径查找包含这个包的子目录。

为了让Python将目录当做内容包，目录中必须包含\_\_init\_\_.py文件。这是为了避免一个含有烂俗名字
的目录无意中隐藏了稍后在模块中出现的有效模块，比如string。虽简单的情况下，只需要一个空的\_\_init\_\_.py
文件即可。当然他也可以执行包的初始化代码，或者定义稍后介绍的\_\_all\_\_变量。

用户可以每次只导入包里的特定模块，例如：
\begin{minted}{pyhton}
import sound.effects.echo
\end{minted}

这样就导入了 sound.effectd.echo 子模块。它必须通过完整的名称来引用：
\begin{minted}{python}
sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
\end{minted}

导入包时有一个可以选择的方式：
\begin{minted}{python}
from sound.effectd import echo
\end{minted}

这样就加载了echo子模块，并且使得它在没有包前缀的情况下也可以使用，所以它可以如下方式调用：
\begin{minted}{python}
echo.echofilter(input, output, delay=0.7, atten=4)
\end{minted}

还有另一种变体用于直接导入函数或变量:
\begin{minted}{python}
from sound.effects.echo import echofilter
\end{minted}

这样就又一次加载了 echo 子模块，但这样就可以直接调用它的 echofilter() 函数：
\begin{minted}{python}
echofilter(input, output, delay=0.7, atten=4)
\end{minted}

需要注意的是使用 from package import item 方式导入包时，这个子项（item）既可以是包中的一个子模块（或一个子包），
也可以是包中定义的其它命名，像函数、类或变量。
import 语句首先核对是否包中有这个子项，如果没有，它假定这是一个模块，并尝试加载它。如果没有找到它，会引发一个 ImportError 异常。

相反，使用类似 import item.subitem.subsubitem 这样的语法时，这些子项必须是包，最后的子项可以是包或模块，
但不能是前面子项中定义的类、函数或变量。

\subsubsection{从*导入包}
\subsubsection{包内引用}




\end{document}
