%-*- coding: UTF-8 -*-
\documentclass[UTF8]{ctexart}
\usepackage{geometry}
\geometry{a4paper,centering,scale=0.8}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{float}
\usepackage{minted}

\title{\heiti Python 基础篇}
\author{卢婧宇}

\begin{document}
\maketitle
\tableofcontents

\newpage
\section{开胃菜}
虽然 Python 易于使用，但它却是一门完整的编程语言；与 Shell 脚本或批处理文件相比，它为编写大型程序提供了更多的结构和支持。
另一方面，Python提供了比C更多的错误检查，并且作为一门高级语言，它内置支持高级的数据结构类型，例如：灵活的数组和字典。

Python允许你将程序分割为不同的模块，以便在其他的Python程序中重用。Python内置提供了大量的标准模块，你可以将其用作程序的基础，
或者作为学习Python编程的示例。这些模块提供了诸如文件I/O、系统调用、Socket支持，甚至类似Tk的用户图形界面（GUI)工具包借口。

Python是一门解释型语言，因为无需编译和链接，你可以在程序开发中节省宝贵的时间。Python解释器可以交互的使用，这使得试验语言的特性、
编写临时程序或在自底向上的程序开发中测试方法非常容易。你甚至还可以把它当做一个桌面计算器。

Python让程序编写的紧凑和可读。用Python编写的程序通常比同样的C、C++或Java程序更短小，原因如下：
\begin{itemize}
  \item 高级数据结构使你可以在一条语句中表达复杂的操作
  \item 语句组使用缩进代替开始和结束大括号来组织
  \item 变量或参数无需声明
\end{itemize}

Python是可扩展的：如果你会C语言编程便可以轻易地为解释器\footnote{解释器，又译为直译器，是一种电脑程序，能够把高级编程语言一行一行直接转译运行。}
添加内置函数或模块，或者为了对性能瓶颈作优化，或者将Python程序与只有二进制形式的库（比如末各专业的商业图形库）连接起来。
一旦你真正掌握了它，你可以将Python解释器集成进某个C应用程序，并把它当作那个程序的扩展命令行语言。
\section{使用Python解释器}
\subsection{调用Python解释器}
Python解释器通常被安装在目标机器的 $/$usr$/$local$/$bin$/$python3.5 目录下。将 $/$usr$/$local$/$bin 目录包含进 Unix shell的搜索路径里，
以确保可以通过输入：Python3.5 命令启动。由于Python解释器的安装路径是可选的，这也可能是其他路径，你可以联系安装Python的用户或系统管理员确认
（例如，/usr/local/python 就是一个常见的选择）。文件结束符Unix系统是：Control + D

第二种启动Python解释器的方法是 Python -c command [arg] ...,这种方法可以在命令行执行Python语句，类似于shell中的 -c选项。由于Python语句通常会包含
空格或其他特殊shell字符，一般建议将命令用单引号包裹起来。

有一些Python模块也可以当做脚本使用。你可以使用 python -m module [arg] ... 命令调用它们，这类似在命令行中键入完整的路径名执行模块源文件一样。
使用脚本文件时，经常会运行脚本然后进入交互模式。这也可以通过在脚本之前加上 -i参数来实现。
\subsubsection{交互模式}
从tty读取命令时，我们称解释器工作于交互模式。这种模式下他根据主提示符来执行，主提示符通常标识为三个大于号（$>>>$);继续的部分被称为从属提示符，由三个
点标识（...)。在第一行之前，解释器打印欢迎信息、版本号和授权提示
\subsubsection{参数传递}
调用解释器时，脚本名和附加参数传入一个名为 sys.argv的字符串列表。你能够获取这个列表通过执行 import sys,列表的长度大于等于1；
没有给定脚本和参数时，它至少也有一个元素：sys.argv[0]此时为空字符串。脚本名指定为`-'（表示标准输入）时，sys.argv[0]被定义为`-',使用 -c 指令时，sys.argv[0]
被设定为`-c'。使用-m模块参数时，sys.argv[0]被设定为指定模块的全名。-c 指令或者 -m 模块之后的参数不会被Python解释器的选项处理机制所截获，而是留在sys.argv中，
供脚本命令操作。
\section{Python简介}
输入和输出分别由大括号和句号提示符（$>>>$ 和 ...)标注。

Python中的注释以\#字符起始，直至实际的行尾。注释可以从行首开始，也可以在空白或代码之后，但是不出现在字符串中。
文本字符串中的\#字符仅仅表示\#。
\subsection{将Python当做计算器}
\subsubsection{数字}
解释器表现得就像一个简单的计算器：可以向其录入一些表达式，它会给出返回值。表达式语法很直白：运算符$+，-，*$和$/$与其他语言一样；括号用于分组。

整数（例如，2，4，20）的类型是int，带有小数部分的数字（例如，5.0，1.6）的类型是float。Python2除法想要得到浮点型，除数或被除数应是浮点型。
Python3除法（$/$）永远返回一个浮点数,如果要使用floor除法并且得到整数结果（丢掉任何小数部分），可以使用（$//$）运算符；要计算余数使用 \% 。
可以使用$**$运算符计算幂乘方。用等号（$=$）用于给变量赋值。赋值之后在下一个提示符之前不会有任何结果显示。

变量在使用前必须“定义”（赋值），否则会出错。浮点数有完整的支持；整数和浮点数的混合计算中，整数会被转换为浮点数。

交互模式中，最近一个表达式的值赋给变量`\_'。这样我们就可以吧它当做一个桌面计算器：

\begin{minted}{python}
>>> t=12.5/100
>>> p=100.50
>>> p*t
12.5625
>>> p+ _
113.0625
\end{minted}

此变量对于用户是只读的。不要尝试给它赋值——你只会创建一个独立的同名局部变量，它屏蔽了系统内置变量的魔术效果。

除了int和float，Python还会支持其它数字类型，例如Decimal和Fraction。Python还内建支持复数，使用后缀 j 或 J 表示虚数部分
（例如，3+5j）。
\subsubsection{字符串}
相比数值，Python也提供了可以通过几种不同方式表示的字符串。它们可以用单引号（`...')或双引号（``...''）标识。
 \textbackslash 可以用来转义引号：
\begin{minted}{python}
>>> 'spam eggs' #single quotes
'spam eggs'
>>>'doesn\'t'  #use \' to escape the single quote...
"doesn't"
>>> '"Yes,"he said.'
'"Yes,"he said.'
>>> "\"Yes,\"he said."
'"Yes,"he said.'
>>> '"Isn\'t,"she said.'
'"Isn\'t,"she said.'
\end{minted}

在交互式解释其中，输出的字符串会用引号引起来，特殊字符会用反斜杠转义。虽然可能和输入看上去不太一样，但是两个字符串是相等的。
如果字符串中只有单引号而没有双引号，就用双引号引用，否则用单引号引用。
print()函数生成可读性更好的输出，它会省去引号并且打印出转义后的特殊字符：
\begin{minted}{python}
>>> '"Isn\'t,"she said.'
'"Isn\'t,"she said.'
>>> print('"Isn\'t." she said.')
"Isn't." she said.
>>> s='First line.\nSecond line.'  # \n means newline
>>> s  # without print(), \n is included in the output
'First line.\nSecond line.'
>>> print(s)  #with print(),\n produces a new line
First line.
Second line.
\end{minted}

如果你前面带有 \textbackslash 的字符被当作特殊字符，你可以使用原始字符串，方法是在第一个引号前面加上一个r。

字符串文本能够分成多行。一种方法是使用三引号：\verb|"""|...\verb|"""|或者 ```...'''。行尾换行符会自动包含到字符串中，
但是可以在行尾加上 \textbackslash
来避免这个行为。可以使用反斜杠为行结尾的字符串，他表示下一行在逻辑上是本行的后续内容。

字符串可以由 $+$ 操作符连接（粘到一起），可以由 $*$ 表示重复。相邻两个字符串文本自动连接在一起。
它只用于两个字符串文本，不能用于字符串表达式：
\begin{minted}{python}
>>> prefix='Py'
>>> prefix 'thon' # can't concatenate a variable and a string literal
...
SyntaxError: invalid syntax
>>> ('un'*3) 'ium'
...
SyntaxError: invalid syntax
\end{minted}


如果你想连接多个变量或者连接一个变量和一个字符串文本，使用 $+$。这个功能在你想切分很长的字符串的时候特别有用:
\begin{minted}{python}
>>> text=('Put several string within parerheses'
...       'to have them joined together.')
>>> text
'Put several string within parerhesesto have them joined together.'
\end{minted}

字符串也可以被截取（检索）。类似于C，字符串的第一个字符索引为0。Python没有单独的字符类型；一个字符就是一个简单的长度为1的字符串。
\begin{minted}{python}
>>> word='Python'
>>> word[0] # character in position 0
'P'
>>> word[5] # character in position 5
'n'
\end{minted}
索引也可以是负数，这将导致从右边开始计算。例如：
\begin{minted}{python}
>>> word[-1] #last character
'n'
>>> word[-2] #second-last character
'o'
>>> word[-6]
'P'
\end{minted}

请注意$-0$实际上就是0，所以他不会导致从右边开始计算。

除了索引，还支持切片。索引用于获得单个字符，切片让你获得一个子字符串:
\begin{minted}{python}
>>> word[0:2] # character from position 0(included)to 2 (excluded)
'Py'
>>> word[2:5] # character from position 2(included) to 5(excluded)
'tho'
\end{minted}

注意，包含起始的字符，不包含末尾的字符。这使得s[:i]+s[i:]永远等于s,：
\begin{minted}{python}
>>> word[:2]+word[2:]
'Python'
>>> word[:4]+word[4:]
'Python'
\end{minted}

切片的索引有非常有用的默认值；省略的第一个索引默认为零，省略的第二个索引默认为切片的字符串的大小。:
\begin{minted}{python}
>>> word[:2]
'Py'
>>> word[4:]
'on'
>>> word[-2:]
'on'
\end{minted}

有个办法可以很容易地记住切片的工作方式：切片时的索引是在两个字符之间。左边第一个字符的索引为0，而长度为n的字符串最后一个字符的右界索引为n。例如：

+---+---+---+---+---+---+

| P | y | t | h | o | n |

+---+---+---+---+---+---+

0   1   2   3   4   5   6

-6  -5  -4  -3  -2  -1

文本中的第一行数字给出字符串的索引点0...6。第二行给出相应的负索引。切片是从i到j两个数值表示的边界之间的所有字符。

对于非负索引，如果上下都在边界内，切片长度就是两个索引之差。

试图使用太大索引会导致错误。
\begin{minted}{python}
>>> word[42] # the word only has 6 characters
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
\end{minted}

Python能够优雅地处理那些没有意义的切片索引：一个过大的索引值（即下标值大于字符串实际长度）将被字符串实际长度所替代，
当上边界比下边界大时（即切片左值大于右值）就返回空字符串:
\begin{minted}{python}
>>> word[4:42]
'on'
>>> word[42:]
''
\end{minted}

Python字符串不可以被更改——它们是不可变的。因此，赋值给字符串索引的位置会导致错误。:
\begin{minted}{python}
>>> word[0]='J'
...
TypeError: 'str' object does not support item assignment
>>> word[2:]='py'
...
TypeError: 'str' object does not support item assignment
\end{minted}

如果你需要一个不同的字符串，你应该创建一个新的:
\begin{minted}{python}
>>> 'J'+word[1:]
'Jython'
>>> word[:2]+'py'
'Pypy'
\end{minted}

内置函数 len() 返回字符串长度:
\begin{minted}{python}
>>> s='supercalifragilisticexpialidocious'
>>> len(s)
34
\end{minted}

\subsubsection{列表}
Python有几个复合数据类型，用于表示其它的值。最通用的是list（列表），它可以写作中括号之间的一列逗号分隔的值。列标的元素不必是同一类型：
\begin{minted}{python}
>>> squares=[1, 4, 9, 16, 25]
>>> squares
[1, 4, 9, 16, 25]
\end{minted}

就像字符串（以及其它所有内建的序列类型）一样，列表可以被索引和切片：
\begin{minted}{python}
>>> squares[0] # indexing returns the item
1
>>> squares[-1]
25
>>> squares[-3:] #slicing return a new list
[9, 16, 25]
\end{minted}

所有的切片操作都会返回一个包含请求的元素的新列表。这意味着下面的切片操作返回列表一个新的（浅）拷贝副本：
\begin{minted}{python}
>>> squares[:]
[1, 4, 9, 16, 25]
\end{minted}

列表也支持连接这样的操作：
\begin{minted}{python}
>>> squares + [36, 49, 64, 81, 100]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
\end{minted}

不像不可变的字符串，列表是可变的，它允许修改元素：
\begin{minted}{python}
>>> cubes=[1, 8, 27, 65, 125] #something's wrong here
>>> 4 ** 3 #the cub of 4 is 64,not 65!
64
>>> cubes[3]=64 # replace the wrong value
>>> cubes
[1, 8, 27, 64, 125]
\end{minted}

还可以使用 append()方法在列表的末尾添加新的元素:
\begin{minted}{python}
>>> cubes.append(216) #add the cube of 6
>>> cubes.append(7 ** 3) # add the cube of 7
>>> cubes
[1, 8, 27, 64, 125, 216, 343]
\end{minted}

也可以对切片赋值，此操作可以改变列表的尺寸，或清空它：
\begin{minted}{python}
  >>> letters=['a','b','c','d','e','f','g']
  >>> letters
  ['a', 'b', 'c', 'd', 'e', 'f', 'g']
  >>> #replace some values
  ... letters[2:5]=['C','D','E']
  >>> letters
  ['a', 'b', 'C', 'D', 'E', 'f', 'g']
  >>> # now remove them
  ... letters[2:5]=[]
  >>> letters
  ['a', 'b', 'f', 'g']
  >>> # clear the list by replacing all the elements with an empty list
  ... letters[:]=[]
  >>> letters
  []
\end{minted}

内置函数 len() 同样适用于列表：
\begin{minted}{python}
  >>> letters=['a','b','c','d']
  >>> len(letters)
  4
\end{minted}

允许嵌套列表（创建一个包含洽谈列表的列表），例如：
\begin{minted}{python}
>>> a=['a','b','c']
>>> n=[1,2,3]
>>> x=[a,n]
>>> x
[['a', 'b', 'c'], [1, 2, 3]]
>>> x[0][1]
'b'
\end{minted}

\subsection{编程的第一步}
当然，我们可以使用Python完成比二加二更复杂的任务。例如，我们可以写一个生成斐波那契子程序的程序，如下所示：
\begin{minted}{python}
>>> # Fibonacci series:
... # the sum of two elements defines the next
... a, b = 0,1
>>> while b<10:
...    print(b)
...    a, b = b, a+b
...
1
1
2
3
5
8
\end{minted}

这个例子介绍了几个新功能。
\begin{itemize}
  \item 第一行包括了一个多重赋值：变量a 和b同时获得了新的值0和1最后一行又使用了一次。在这个演示中，变量赋值前，右边首先完成计算。右边的
  表达式从左到右计算。
  \item 条件（这里是 b<10）为true时，while循环执行。在Python中，类似于C，任何非零整数都是true;0是false。条件也是可以
  是字符串或列表，实际上可以使任何序列；所有长度不为零的是true，空序列是false。示例中的测试是一个检点的比较。
  标准比较操作符与C相同：< , > , == , <= , >= 和 ！=。
  \item 循环体是缩进的：缩进是Python组织语句的方法。Python(还)不提供集成的行编辑功能，所以你要为每一个缩
  进行输入TAB或空格。

  实践中建议你找个文本编辑来录入复杂的Python程序，大多数文本编辑器提供自动缩进。交互式录入复合语句时，必须在最后一个
  空行来标识结束（因为解释器没办法猜测你输入的哪一行是最后一行），需要注意的是同一个语句块中的每一行必须缩进同样数量的空白
  \item 关键字print() 语句输出给定表达式的值。它控制多个表达式和字符串输出为你想要字符串（就像在前面计算器的例子中那样）。

  字符串打印时不用引号包围，每两个子项之间插入空间，所以你可以把格式弄得很漂亮，像这样
  \begin{minted}{python}
    >>> i=256*256
    >>> print('The value of i is',i)
    The value of i is', 65536
  \end{minted}

  一个逗号结尾就可以禁止输出换行：
  \begin{minted}{python}
    >>> a, b=0 ,1
    >>> while b < 1000:
    ...     print(b, end=',')
    1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,
  \end{minted}
\end{itemize}

\section{深入Python流程控制}
除了前面介绍的while语句，Python还从其他语言借鉴了一些流程控制功能，并有所改变。
\subsection{if语句}
也许最有名的就是if语句。例如：
\begin{minted}{python}
  >>> x = int(input("Please enter an integer: "))
  Please enter an integer: 42
  >>> if x < 0:
  ...     x = 0
  ...     print('Negative changed to zero')
  ... elif x==0:
  ...     print('Zero')
  ... elif x==1:
  ...     print('Single')
  ... else:
  ...     print('More')
  ...
  More
\end{minted}
可能会有零到多个elif部分，else是可选的。关键字`elif'是`else if'的缩写，这个可以有效地避免
过深的缩进。if ... elif ... elif ...序列用于代替其他语言中的 swith 或 case 语句。
\subsection{for语句}
Python中的for语句和C或Pascal中的略有不同。通常的循环可能会依据一个等差数值步进过程（如Pascal）
，或由用户来定义迭代步骤和终止条件（如C），Python的for语句依据任意序列（链表或字符串）中的子项
，按它们在序列中的顺序来进行迭代。例如（没有暗指）：
\begin{minted}{python}
>>> # Measure some strings:
... words = ['cat', 'window', 'defenestrate']
>>> for w in words:
...     print(w, len(w))
...
cat 3
window 6
defenestrate 12
\end{minted}
在迭代过程中修改序列不安全（只有在使用链表这样的可变序列时才会有这样的情况）。
如果你想要修改你的迭代的序列（例如，复制选择项），你可以迭代它的副本。使用切割标识就可以很方便
的做到这一点：
\begin{minted}{python}
>>> for w in words[:]:
...     if len(w) > 6:
...             words.insert(0, w)
...
>>> words
['defenestrate', 'cat', 'window', 'defenestrate']
\end{minted}
\subsection{range()函数}
如果你需要一个数值序列，内置函数range()会很方便，它生成一个等差级数链表：
\begin{minted}{python}
>>> for i in range(5):
...     print(i)
...
0
1
2
3
4
\end{minted}
range(10)生成了一个包含10个值的链表，他用链表的索引值填充了这个长度为10的列表，
所生成的链表中不包括范围中的结束值。也可以让range()操作从另一个数值开始，或者可以指定一个不同
的步进值（甚至是负数，有时这也被称为步长)
\begin{minted}{python}
range(5, 10)
  5 through 9
range(0, 10, 3)
  0, 3, 6, 9
range(-10, -100, -30)
  -10, -40, -70
\end{minted}
需要迭代链表索引的话，如下所示结合使用用 range() 和 len()
\begin{minted}{python}
>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
...     print(i, a[i])
...
0 Mary
1 had
2 a
3 little
4 lamb
\end{minted}
不过，这种场合可以方便的使用 enumerate(),请参见 循环技巧。

如果你只是打印一个序列的话会发生奇怪的事情：
\begin{minted}{python}
>>> print(range(10))
range(0, 10)
\end{minted}
在不同方面range()函数返回的对象表现为它是一个列表，但事实上它并不是。当你迭代它时，
它是一个能够像期望的序列返回连续项的对象；但为了节省空间，他并不真正构造列表。

我们称此类对象是可迭代的，即适合作为那些期望从某些东西中获得连续项直到结束的函数
或结构的一个目标（参数）。我们已经见过的for语句就是这样一个迭代器。list()函数是
另外一个（迭代器），他从可迭代（对象）中创建列表：
\begin{minted}{python}
>>> list(range(5))
[0, 1, 2, 3, 4]
\end{minted}
稍后我们会看到更多返回可迭代（对象）和以可迭代（对象）作为参数的函数。

\subsection{break 和 continue 语句，以及循环中的else子句}
break语句和C中的类似，用于跳出最近的一级for或while循环。

循环可以有一个else子句；它在循环迭代完整个列表（对于for）或执行条件为false（对于while）时
执行，但循环被break中止的情况不会执行。以下搜索素数的示例程序演示了这个子句：
\begin{minted}{python}
>>> for n in range(2, 10):
...     for x in range(2, n):
...             if n % x == 0:
...                     print(n, 'equals', x, '*', n//x)
...                     break
...     else:
...         # loop fell through without finding s factor
...             print(n, 'is a prime number')
...
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3
\end{minted}
(Yes,这是正确的代码。看仔细：else 语句是属于 for 循环之中，不是 if 语句。)

与循环一起使用时，else子句与try语句的else子句比与if语句的具有更多的共同特点：try 语句的 else
子句在未出现异常时运行，循环的else子句在未出现break时运行。更多关于 try 语句和异常的内容，请参见异常处理。

continue 语句是从C中借鉴来的，它表示循环继续执行下一次迭代：
\begin{minted}{python}
  >>> for num in range(2, 10):
  ...     if num % 2 ==0:
  ...             print("Found an even number", num)
  ...             continue
  ...     print("Found a number", num)
  ...
  Found an even number 2
  Found a number 3
  Found an even number 4
  Found a number 5
  Found an even number 6
  Found a number 7
  Found an even number 8
  Found a number 9
\end{minted}

\subsection{pass语句}
pass语句什么也不做。它用于那些语法上必须要有什么语句，但程序什么也不做的场合，例如：
\begin{minted}{python}
  >>> while True:
  ...     pass # Busy-wait for keyboard interrupt (Ctrl+C)
  ...
\end{minted}
者通常用于创建最小结构的类：
\begin{minted}{python}
>>> class MyEmptyClass:
...     pass
...
\end{minted}
另一方面，pass可以在创建新代码时用来做函数或控制体的占位符。可以让你在更抽象的级别上思考。
pass可以默默的被忽视：
\begin{minted}{python}
>>> def initlog(*args):
...     pass  # Remember to implement this!
...
\end{minted}

\subsection{定义函数}
我们可以创建一个用来生成指定边界的斐波那契数列的函数：
\begin{minted}{python}
>>> def fib(n):  # write Fibonacci series up to n
...     """Print a Fibonacci series up to n."""
...     a, b = 0, 1
...     while a < n:
...             print(a, end=' ')
...             a, b = b, a+b
...     print()
...
>>> # Now call the function we just defined:
... fib(2000)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
\end{minted}

关键字 def 引入了一个函数定义。在其后必须跟有函数名和包括形式参数的圆括号。函数体语句从下一行
开始，必须是缩进的。

函数体第一行语句可以是可选的字符串文本，这个字符串是函数的文档字符串，或者称为 docstring。（更多关于 docstring 的
信息请参考文档字符串）有些工具通过 docstrings 自动生成在线的或可打印的文档，或者让用户通过代码交互浏览；
在你的代码中包含 docstrings 是一个好的实践，让它成为习惯吧。

函数调用会为函数局部变量生成一个新的符号表。确切的说，所有函数中的变量赋值都是将值存储在局部符号表。变量引用首先在局部符号表中
查找，然后是包含函数的局部符号表，最后是内置名字表。因此，全局变量不能在函数中直接赋值（除非用 global语句命名），尽管他们可以被引用。

函数引用的实际参数在函数调用时引入局部符号表，因此，实参总是传值调用（这里的值总是一个对象引用，而不是该对象的值）。
一个函数被另一个函数调用时，一个新的局部符号表在调用过程中被创建。

一个函数定义会在当前符号表内引入函数名。函数名指代的值（即函数体）有一个被Python 解释器认定为用户自定义函数的类型。这个值可以
赋予其他的名字（即变量名），然后它也可以被当做函数使用。这可以作为通用的重命名机制：
\begin{minted}{python}
>>> fib
<function fib at 0x102aa29d8>
>>> f=fib
>>> f(100)
0 1 1 2 3 5 8 13 21 34 55 89
\end{minted}
如果你使用过其他语言，你可能会反对说：fib不是一个函数，而是一个方法因为它并不返回任何值。事实上，没有return语句的函数确实会返回一个值，
虽然是一个相当令人厌烦的值（指None）。这个值被称为None(这是一个内建名称)。如果None值是唯一被书写的值，那么在写的时候通常会被解释器
忽略（即不输出任何内容）。如果你确实想看到这个值的输出内容，请使用print()函数：
\begin{minted}{python}
>>> fib(0)
>>> print(fib(0))
None
\end{minted}

定义一个返回斐波那契数列数字列表的函数，而不是打印它，是很简单的：
\begin{minted}{python}
>>> def fib2(n): #return Fibonacci series up to n
...     """Return a list containing the Fibonacci series up to n."""
...     result = []
...     a, b = 0, 1
...     while a < n:
...             result.append(a)  # see below
...             a, b = b, a+b
...     return result
...
>>> f100 = fib2(100) # call it
>>> f100             # write the reslut
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
\end{minted}

和以前一样，这个例子演示了一些新的Python功能：
\begin{itemize}
  \item return语句从函数中返回一个值，不带表达式的return返回None。过程结束后也会返回None。
  \item 语句result.append(b)称为链表对象 result的一个方法。方法是一个``属于''某个对象的函数，它被命名为obj.methodename,
  这里的obj是某个对象（可能是一个表达式），methodename是某个在该对象类型定义中的方法的命名。

  不同类型定义不同的方法。不同类型可能有同样名字的方法，但不会混淆。（当你定义自己的对象类型和方法时，可能会出现这种情况，
  class的定义方法详见类）。示例中演示的 append()方法由链表对象定义，它向链表中加入一个新元素。在示例中他等同于
  result =result +[a],不过效率更高。
\end{itemize}

\subsection{深入Python函数定义}
在Python中，你也可以定义包含若干参数的函数。这里有三种可用的形式，也可以混合使用。
\subsubsection{默认参数值}
最常用的一种形式是为一个或多个参数指定默认值。这会创建一个可以使用比定义时允许的参数更少的参数调用的函数，例如:
\begin{minted}{python}
>>> def ask_ok(prompt, retries=4, complaint='Yes or no, please!'):
...     while True:
...             ok = input(prompt)
...             if ok in ('y', 'ye', 'yes'):
...                     return Ture
...             if ok in ('n', 'no', 'nop', 'nope'):
...                     return False
...             retries = retries - 1
...             if retries < 0:
...                     raise OSError('uncooperat user')
...             print(complaint)
\end{minted}

这个函数可以通过几种不同的方式调用：
\begin{itemize}
  \item 只给出必要的参数：ask\_ok $($`Do you really want to quit?'$)$
  \item 给出一个可选的参数：

  ask\_ok$($`Ok to overwrite the file?', 2$)$
  \item 或者给出所有的参数：

  ask\_ok$($`OK to overwrite the file?', 2, `Come only yes or no!'$)$
\end{itemize}

这个例子还介绍了 in 关键字。它测定序列中是否包含某个确定的值。

默认值在函数定义作用域被解析，如下所示：
\begin{minted}{python}
>>> i = 5
>>> def f(arg = i):
...     print(arg)
...
>>> i = 6
>>> f()
5
\end{minted}

重要警告：默认值只被赋值一次。这使得当默认值是可变对象时会有所不同，比如列表、字典或者大多数类的实例。
例如，下面的函数在后续调用过程中会累积（前面）传给它的参数：
\begin{minted}{python}
>>> def f(a, L=[]):
...     L.append(a)
...     return L
...
>>> print(f(1))
[1]
>>> print(f(2))
[1, 2]
>>> print(f(3))
[1, 2, 3]
\end{minted}

如果你不想让默认值在后续调用中累积，你可以像下面一样定义函数：
\begin{minted}{python}
>>> def f(a, L=None):
...     if L is None:
...             L = []
...     L.append (a)
...     return L
\end{minted}

\subsubsection{关键字参数}
函数可以通过关键字参数的形式来调用，形如 keyword = value。例如，以下的函数：
\begin{minted}{python}
>>> def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
...     print("-- This parrot wouldn't", action, end=' ')
...     print("if you put", voltage, "volts through it.")
...     print("-- Lovely plumage, the", type)
...     print("-- It's", state, "!")
\end{minted}

接受一个必选参数（voltage）以及三个可选参数（state, action和type）。可以用以下的任一方法调用：
\begin{minted}{python}
>>> parrot(1000)                      # 1 positional argument
-- This parrot wouldn't voom if you put 1000 volts through it.
-- Lovely plumage, the Norwegian Blue
-- It's a stiff !
>>> parrot(voltage=1000)              # 1 keyword argument
-- This parrot wouldn't voom if you put 1000 volts through it.
-- Lovely plumage, the Norwegian Blue
-- It's a stiff !
>>> parrot(voltage=1000000, action='VOOOOOM')  # 2 keyword arguments
-- This parrot wouldn't VOOOOOM if you put 1000000 volts through it.
-- Lovely plumage, the Norwegian Blue
-- It's a stiff !
>>> parrot(action='VOOOOOM',voltage=1000000)   # 2 keyword arguments
-- This parrot wouldn't VOOOOOM if you put 1000000 volts through it.
-- Lovely plumage, the Norwegian Blue
-- It's a stiff !
>>> parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword
-- This parrot wouldn't voom if you put a thousand volts through it.
-- Lovely plumage, the Norwegian Blue
-- It's pushing up the daisies !
\end{minted}

不过以下几种调用是无效的：
\begin{minted}{python}
>>> parrot()                     # requried argument missing
>>> parrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword argument
>>> parrot(110, voltage=220)     # duplicate value for the same argument
>>> parrot(actor='John Cleese')  # unknow keyword argument
\end{minted}

在函数调用中，关键字的参数必须跟随在位置参数的后面。传递的所有关键字参数必须与函数接受的某个参数相匹配
（例如 actor 不是 parrot 函数的有效参数），它们的顺序并不重要。这也包括非可选参数（例如 parrot(voltage=100)也是有效的）。
任何参数都不可以多次赋值。下面的示例由于这种限制将失败:
\begin{minted}{python}
>>> def function(a):
...     pass
...
>>> function(0, a=0)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: function() got multiple values for argument 'a'
\end{minted}

引入一个形如 $**$name 的参数时，它接收一个字典（参见Mapping Types-dict）,该字典包含了所有未出现在形式参数列表中的关键字参数。
这里可能还会组合使用一个形如 $*$name （下一小节详细介绍）的形式参数，它接收一个元组（下一节中会详细介绍），包含了所有没有出现在形式参数
列表中的参数值（ $*$name必须在 $**$name之前出现）。例如，我们这样定义一个函数：
\begin{minted}{python}
>>> def cheeseshop(kind, *arguments, **keywords):
...     print("-- Do you have any", kind, "?")
...     print("-- I'm sorry. we're all out of", kind)
...     for arg in arguments:
...             print(arg)
...     print("-" * 40)
...     keys = sorted(keywords.keys())
...     for kw in keys:
...             print(kw, ":", keywords[kw])
\end{minted}

它可以像这样调用：
\begin{minted}{python}
>>> cheeseshop("Limburger", "It's very runny, sir.",
...             "It's really very, VERY runny, sir.",
...             shopkeeper="Michael Palin."
...             client="John Cleese",
...             sketch="Cheese Shop Sketch")
\end{minted}

当然它会按如下内容打印：
\begin{minted}{python}
-- Do you have any Limburger ?
-- I'm sorry, we're all out of Limburger
It's very runny, sir.
It's really very, VERY runny, sir.
----------------------------------------
client : John Cleese
shopkeeper : Michael Palin
sketch : Cheese Shop Sketch
\end{minted}

注意在打印关键字参数之前，通过对关键字字典 keys() 方法的结果进行排序，生成了关键字参数名的列表；
如果不这样做，打印出来的参数顺序是未定义的。

\subsubsection{可变参数列表}
最后，一个最不常用的选择是可以让函数调用可变个数的参数。这些参数被包装进一个元祖（参见 元祖和序列）。
在这个可变个数的参数之前，可以有零到多个普通的参数：
\begin{minted}{python}
>>> def concat(*args, sep="/"):
...     return sep.join(args)
...
>>> concat("earth", "mars", "venus")
'earth/mars/venus'
>>> concat("earth", "mars", "venus", sep=".")
'earth.mars.venus'
\end{minted}
\subsubsection{参数列表的拆分}
另一种相反的情况：当你要传递的参数已经是一个列表，但要调用的函数却接受分开一个个的参数值。
这时候你要把已有的列表拆开来。例如内建函数 range()需要要独立的 start, stop参数。
你可以在调用函数时加一个$*$操作符来自动把参数列表拆开：
\begin{minted}{python}
>>> list(range(3, 6))   # normal call with separate arguments
[3, 4, 5]
>>> args = [3, 6]
>>> list(range(*args))  # call with arguments unpacked from a list
[3, 4, 5]
\end{minted}

以同样的方法，可以使用$**$操作符拆分关键字参数为字典：
\begin{minted}{python}
>>> def parrot(voltage, state='a stiff', action='voom'):
...     print("-- This parrto wouldn't", action, end=' ')
...     print("if you put", voltage, "volts through it.", end=' ')
...     print("E's", state, "!")
...
>>> d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
>>> parrot(**d)
-- This parrto wouldn't VOOM if you put four million volts through it. E's bleedin' demised !
\end{minted}

\subsubsection{Lambda形式}
出于实际需要，有几种通常在函数式编程语言例如Lisp中出现的功能加入到了Python。通过lambda关键字，
可以创建短小的匿名函数。这里有一个函数返回它的两个参数的和：lambda a, b: a+b。Lambda形式可以用于任何
需要的函数对象。出于语法限制，它们只能有一个单独的表达式。
\begin{minted}{python}
>>> def make_incrementor(n):
...     return lambda x: x + n
...
>>> f = make_incrementor(42)
>>> f(0)
42
>>> f(1)
43
\end{minted}

上面的示例使用lambda表达式返回一个函数。另一个用途是将一个小函数作为参数传递：
\begin{minted}{python}
>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
>>> pairs.sort(key=lambda pair: pair[1])
>>> pairs
[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]
\end{minted}

\subsubsection{文档字符串}
这里介绍的文档字符串的概念和格式。

第一行应该是关于对象用途的简介。简短起见，不用明确的陈述对象名或类型，
因为它们可以从别的途径了解到（除非这个名字碰巧就是描述这个函数操作的动词）。这一行应该
以大写字母开头，以句号结尾。

如果文档字符串有多行，第二行应该空出来，与接下俩的详细描述明确分隔。接下来的文档婴孩有一
或多段描述对象的调用约定、边界效应等。

Python的解释器不会从多行的文档字符串中取除缩进，所以必要的时候应当自己清除缩进。这符合通常的习惯。
第一行之后的第一个非空行决定了整个文档的缩进格式。（我们不用第一行是因为它通常紧靠着起始的引号，缩进
的话，所有的留白都应该清除掉。留白的长度应当等于扩展制表符的宽度（通常是8个空格）。

以下是一个多行文档字符串的示例：
\begin{minted}{python}
>>> def my_function():
...     """Do nothing, but document it.
...
...     No, really, it doesn't do anything.
...     """
...     pass
...
>>> print(my_function.__doc__)
Do nothing, but document it.

	No, really, it doesn't do anything.
\end{minted}

\section{数据结构}
\subsection{关于列表的更多的内容}
Python的列表数据类型包含更多的方法。这里是所有的列表对象方法：
\begin{itemize}
  \item list.append(x) 把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]
  \item list.extend(L) 将一个给定列表中的所有元素都添加到另一个列表中，相当于 a[len(a):]=L
  \item list.insert(i,x) 在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，
  例如 a.insert(0, x)会插入到整个列表之前，而 a.insert(len(a), x)相当于 a.append(x)。
  \item list.remove(x) 删除列表中值为x的第一个元素。如果没有这样的元素，就会返回一个错误。
  \item list.pop([i]) 从列表的指定位置删除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。
  元素随机从列表中被删除（方法中i两边的方括号表示这个参数是可选的，而不是要求你的输入一对方括号，你会经常
  在Python库参考手册中遇到这样的标记）。
  \item list.clear() 从列表中删除所有元素。相当于 del a[:]。
  \item list.count(x) 返回x在列表中出现的次数
  \item list.index(x) 返回列表中第一个值为x的元素的索引。如果没有匹配的元素就会返回一个错误。
  \item list.sort() 对类表中的元素就地进行排列。
  \item list.reverse() 就地倒排列表中的元素。
  \item list.copy() 返回列表的一个浅拷贝。等同于 a[:]。
\end{itemize}

下面这个示例演示了列表的大部分方法：
\begin{minted}{python}
>>> a = [66.25, 333, 333, 1, 1234.5]
>>> print(a.count(333), a.count(66.25), a.count('x'))
2 1 0
>>> a.insert(2, -1)
>>> a.append(333)
>>> a
[66.25, 333, -1, 333, 1, 1234.5, 333]
>>> a.index(333)
1
>>> a.remove(333)
>>> a
[66.25, -1, 333, 1, 1234.5, 333]
>>> a.reverse()
>>> a
[333, 1234.5, 1, 333, -1, 66.25]
>>> a.sort()
>>> a
[-1, 1, 66.25, 333, 333, 1234.5]
>>> a.pop()
1234.5
>>> a
[-1, 1, 66.25, 333, 333]
\end{minted}

也许大家会发现像insert, remove 或者sort这些修改列表的方法没有打印返回值——它们
返回None。在python中对所有可变的数据类型这是统一的设计原则。
\subsubsection{把列表当作堆栈使用}
列表方法使得列表可以很方便的作为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素
最后一个被释放（后进先出）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的
 pop() 方法可以把一个元素从堆栈顶释放出来。例如：
 \begin{minted}{python}
 >>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack.append(7)
>>> stack
[3, 4, 5, 6, 7]
>>> stack.pop()
7
>>> stack
[3, 4, 5, 6]
>>> stack.pop()
6
>>> stack.pop()
5
>>> stack
[3, 4]
\end{minted}
\subsubsection{把列表当做队列使用}
你也可以把列表当做队列使用，队列作为特定的数据结构，最先进入的元素最先释放（先进先出）。
不过，列表这样用效率不高。相对来说从列表末尾添加和弹出很快；在头部插入和弹出很慢（因为，
为了一个元素，要移动整个列表中的所有元素）。

要实现队列，使用 collections.deque,它为在首尾两端快速插入和删除而设计。例如：
\begin{minted}{python}
>>> from collections import deque
>>> queue = deque(["Eric", "John", "Michael"])
>>> queue.append("Terry")               # Terry arrives
>>> queue.append("Graham")              # Graham arrives
>>> queue.popleft()                     # The first to arrive now leaves
'Eric'
>>> queue.popleft()                     # The second to arrive now leaves
'John'
>>> queue                               # Remaining queue in order of arrival
deque(['Michael', 'Terry', 'Graham'])
\end{minted}
\subsubsection{列表推导式}
列表推导式为从序列中创建列表提供了一个简单的方法。普通的应用程式通过将一些操作应用于
序列的每个成员并通过返回的元素创建列表，或者通过满足特定条件的元素创建子序列。
\begin{minted}{python}
>>> squares = []
>>> for x in range(10):
...     squares.append(x**2)
...
>>> squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
\end{minted}

注意这个for循环中的被创建（或被重写）的名为x的变量在循环完毕后依然存在。使用如下方法，我们可以计算
squares的值而不会产生任何的副作用：
\begin{minted}{python}
>>> squares = list(map(lambda x: x**2, range(10)))
\end{minted}

或者等价于：
\begin{minted}{python}
squares = [x**2 for x in range(10)]
\end{minted}

上面这个方法更加简明且易读。

列表推导式由包含一个表达式的括号组成，表达式后面跟随一个for子句，之后可以有零个或多个for或if子句。
结果是一个列表，由表达式依据其后面的for和if子句上下文计算而来的结果构成。

例如，如下的列表推导式结合两个列表的元素，如果两个元素之间不相等的话：
\begin{minted}{python}
>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x !=y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
\end{minted}

等同于：
\begin{minted}{python}
>>> combs = []
>>> for x in [1,2,3]:
...     for y in [3,1,4]:
...             if x != y:
...                     combs.append((x,y))
...
>>> combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
\end{minted}

值得注意的是在上面两个方法中的for和if语句的顺序。

如果想要得到一个元组（例如，上面例子中的（x，y)），必须要加上括号：
\begin{minted}{python}
>>> vec = [-4, -2, 0, 2, 4]
>>> # create a new list with the values doubled
>>>[x*2 for x in vec]
[-8, -4, 0, 4, 8]
>>> # filter the list to exclude negative numbers
>>> [x for x in vec if x >= 0]
[0, 2, 4]
>>> # apply a function to all the elements
>>> [abs(x) for x in vec]
[4, 2, 0, 2, 4]
>>> # call a method on each elements
>>> freshfruit = [' banana', ' loganberry', 'passion fruit ']
>>> [weapon.strip() for weapon in freshfruit]
['banana', 'loganberry', 'passion fruit']
>>> # create a list of 2-tuples like (number, square)
>>> [(x, x**2) for x in range(6)]
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
>>> # the tuple must be parenthesized, otherwise an error is raised
>>> [x, x**2 for x in range(6)]
  File "<stdin>", line 1
    [x, x**2 for x in range(6)]
               ^
SyntaxError: invalid syntax
>>> # flatten a list using a listcomp with two 'for'
>>> vec = [[1,2,3], [4,5,6], [7,8,9]]
>>> [num for elem in vec for num in elem]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{minted}

列表推导式可使用复杂的表达式和嵌套函数：
\begin{minted}{python}
>>> from math import pi
>>> [str(round(pi, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
\end{minted}
\subsubsection{嵌套的列表推导式}
列表解析中的第一个表达式可以是任何表达式，包括列表解析。

考虑下面由三个长度为4的列表组成3$\times$4矩阵：
\begin{minted}{python}
>>> matrix = [
...     [1, 2, 3, 4],
...     [5, 6, 7, 8],
...     [9, 10, 11, 12],
... ]
\end{minted}

现在如果你想交换行和列，可以用嵌套的列表推导式：
\begin{minted}{python}
>>> [[row[i] for row in matrix] for i in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
\end{minted}

像前面看到的，嵌套的列表推导式是对for后面的内容进行求值，所以上例就等价于：
\begin{minted}{python}
>>> transposed = []
>>> for i in range(4):
...     # the following 3 lines implement the nested listcomp
...     transposed_row = []
...     for row in matrix:
...             transposed_row.append(row[i])
...     transposed.append(transposed_row)
...
>>> tramsposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
\end{minted}

在实际中，你应该更喜欢使用内置函数组成复杂流程语句。对这种情况 zip()函数将会做的更好：
\begin{minted}{python}
>>> list(zip(*matrix))
[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
\end{minted}

更多关于本行中使用的星号的说明，参考 参数列表的拆分。
\subsection{del语句}
有个方法可以从类表中按给定的索引而不是值来删除一个子项：del语句。它不同于有返回值的
pop()方法。语句del还可以从列表中删除切片或清空整个列表（我们以前介绍过一个方法是将空列表
赋值给列表的切片）。例如：
\begin{minted}{python}
>>> a = [-1, 1, 66.25, 333, 333, 1234.5]
>>> del a[0]
>>> a
[1, 66.25, 333, 333, 1234.5]
>>> del a[2:4]
>>> a
[1, 66.25, 1234.5]
>>> del a[:]
>>> a
[]
\end{minted}

del也可以删除整个变量：
\begin{minted}{python}
>>> del a
>>> a
\end{minted}

此后再引用命名a会引发错误（直到另一个值赋给它为止）。我们在后面的内容中可以看到del的其它用法。
\subsection{元组和序列}
我们知道列表和字符串有很多通用的属性，例如索引和切割操作。它们是序列类型（参见Sequence Types -
list,tuple,range) 中的两种。因为Python是一个在不停进化的语言，也可能会加入其它的序列类型，这里
介绍另一种标准序列类型：元组。

一个元组由数个逗号分隔的值组成，例如：
\begin{minted}{python}
>>> t = 12345, 54321, 'hello!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hello!')
>>> # Tuples may be nested:
... u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
>>> # Tuples are immutable:
... t[0] = 88888
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
TypeError: 'tuple' object does not support item assignment
>>> # but they can contain mutable objects:
... v = ([1, 2, 3], [3, 2, 1])
>>> v
([1, 2, 3], [3, 2, 1])
\end{minted}
正如你所见，元组在输出时总是有括号的，以便于正确表达嵌套结构。在输入时
可以有或没有括号，不过经常括号都是必须的（如果元组是一个更大的表达式的一部分）。
不能给元组的一个独立的元素赋值（尽管你可以通过联接和切割来模拟）。还可以创建包含可变
对象的元组，例如列表。

虽然元组和列表很类似，它们经常被用来在不同的情况和不同的用途。元组有很多用途。例如（x,y）
坐标对，数据库中的员工记录等等。元组就像字符串，不可变的。通常包含不同种类的元素并通过分拆（参阅
本节后面的内容）或索引访问（如果是namedtuples,甚至可以通过属性）。列表是可变的，它们的元素通常是相同类型的并通过迭代访问。

一个特殊的问题是构造包含零个或一个元素的元组：为了适应这种情况，语法上有一些额外的改变。一对空的括号可以创建空元组；
要创建一个单元素元组可以在值后面跟一个逗号（在括号中放入一个单值不够明确）。丑陋，但是有效。例如：
\begin{minted}{python}
>>> empty = ()
>>> singleton = 'hello',     # <-- note trailing comma
>>> len(empty)
0
>>> len(singleton)
1
>>> singleton
('hello',)
\end{minted}

语句 t = 12345, 54321, `hello!' 是元组封装（tuple packing）的一个例子：值12345，54321和`hello'
被封装进元组。其逆操作可能是这样：
\begin{minted}{python}
>>> x, y, z = t
\end{minted}

这个调用等号右边可以是任何线性序列，称之为序列拆分非常恰当。序列拆封要企业左侧的变量数目与序列的元素个数相同。要
注意的是可变参数（multiple assignment)其实只是元组封装的序列拆封的一个结合。

\subsection{集合}
Python还包含了一个数据类型--set（集合）。集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。集合对象还支持
union（联合），intersection（交），difference（差）和sysmmetric difference（对称差集）等数学运算。

大括号或 set() 函数可以用来创建集合。注意：想要创建空集合，你必须要使用 set() 而不是 {}。
后者用于创建空字典。以下是一个简单的演示：
\begin{minted}{python}
>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
>>> print(basket)                     # show that duplicates have been removed
{'pear', 'apple', 'orange', 'banana'}
>>> 'orange' in basket                 # fast membership testing
True
>>> 'crabgrass' in basket
False
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                      # unique letters in a
{'r', 'a', 'd', 'c', 'b'}
>>> a - b                  # letters in a but not in b
{'d', 'r', 'b'}
>>> a | b                  # letters in either a or b
{'r', 'a', 'l', 'd', 'c', 'z', 'm', 'b'}
>>> a & b                  # letters in both a and b
{'a', 'c'}
>>> a ^ b                  # letters in a or b but not both
{'r', 'l', 'z', 'd', 'm', 'b'}
\end{minted}

类似列表推导式，这里有一种集合推导式语法：
\begin{minted}{python}
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'d', 'r'}
\end{minted}

\subsection{字典}
另一个非常有用的Python内建数据类型 是字典（参见Mapping Types - dict）。字典在
某些语言中可能称为 联合内存（associative memories）或联合数组（associative arrays）。
序列是以连续的整数为索引，与此不同的是，字典以关键字为索引，关键字可以是任意不可变类型，通常用字符串或数值。
如果元组中只包含字符串和数字，他可以作为关键字，如果它直接或间接的包含了可变对象，就不能当做
关键字。不能用列表做关键字，因为列表可以用索引、切割或者appen()和extend()等方法改变。

理解字典的最佳方式是把它看做无序的键：值对（key:value对）集合，键必须是互不相同的（在同一个字典之内）。
一对大括号创建一个空的字典： {} 。初始化列表时，在大括号内放置一组逗号分隔的键：值对，这也是字典输出的方式。

字典的主要操作是依据键来存储和析取值。也可以用 del 来删除键：值对（key:value）。如果你用一个已经存在的关键字
存储值，以前为该关键字分配的值就会被遗忘。试图从一个不存在的键中取值会导致错误。

对一个字典执行 list(d.keys()) 将返回一个字典中所有关键字组成的无序列表（如果你想要排序，只需使用 sorted(d.key())
使用 in 关键字（指Python语法）可以检查字典中是否存在某个关键字（指字典）。

字典示例：
\begin{minted}{python}
>>> tel = {'jack': 4098, 'sape': 4139}
>>> tel['guido'] = 4127
>>> tel
{'jack': 4098, 'sape': 4139, 'guido': 4127}
>>> tel['jack']
4098
>>> del tel['sape']
>>> tel['irv'] = 4127
>>> tel
{'jack': 4098, 'guido': 4127, 'irv': 4127}
>>> 'guido' in tel
True
>>> 'jack' not in tel
False
\end{minted}

dict()构造函数可以直接从key-value对中创建字典：
\begin{minted}{python}
>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'guido': 4127, 'jack': 4098}
\end{minted}

此外，字典推导可以从任意的键值表达式中创建字典：
\begin{minted}{python}
>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
\end{minted}

如果关键字都是简单的字符串，有时通过关键字参数指定 key-value 对更为方便：
\begin{minted}{python}
>>> dict(sape=4139, guido=4127, jack=4098)
{'sape': 4139, 'guido': 4127, 'jack': 4098}
\end{minted}

\subsection{循环技巧}
在字典中循环时，关键字和对应的值可以使用 items() 方法同时解读出来：
\begin{minted}{python}
>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
>>> for k,v in knights.items():
...     print(k, v)
...
gallahad the pure
robin the brave
\end{minted}

在序列中循环时，索引位置和对应值可以使用 enumerate() 函数同时得到：
\begin{minted}{python}
>>> for i, v in enumerate(['tic', 'tac', 'toe']):
...     print(i, v)
...
0 tic
1 tac
2 toe
\end{minted}

同时循环两个或更多的序列，可以使用 zip() 整体打包：
\begin{minted}{python}
>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> for q, a in zip(questions, answers):
...     print('What is your {0}? It is {1}.' .format(q, a))
...
What is your name ? It is lancelot.
What is your quest ? It is the holy grail.
What is your favorite color ? It is blue.
\end{minted}

需要逆向循环序列的话，先正向定位序列，然后调用 reversed() 函数：
\begin{minted}{python}
>>> for i in reversed(range(1, 10, 2)):
...     print(i)
...
9
7
5
3
1
\end{minted}

要按排序后的顺序循环序列的话，使用sorted()函数，他不改动原序列，而是生成一个新的已排序的序列：
\begin{minted}{python}
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for f in sorted(set(basket)):
...     print(f)
...
apple
banana
orange
pear
\end{minted}

若要在循环内部修改正在遍历的序列（例如复制某些元素），建议您首先制作副本。在序列上循环不会隐式地创建
副本。切片表示法使用这尤其方便：
\begin{minted}{python}
>>> words = ['cat', 'window', 'defenstrate']
>>> for w in words[:]:      # Loop over a slice copy of the entire list.
...     if len(w) > 6:
...             words.insert(0, w)
...
>>> words
['defenstrate', 'cat', 'window', 'defenstrate']
\end{minted}

\subsection{深入条件控制}
while 和 if 语句中使用的条件不仅可以使用比较，而且可以包含任意的操作。

比较操作符 in 和 not in 审核值是否在一个区间之内。操作符 is 和 is not 比较两个对象时否相同；
这只和诸如列表这样的可变对象有关。所有的比较操作符具有相同的优先级，低于所有的数值操作。

比较操作可以传递。例如 a < b == c 审核是否 a 小于 b 并且 b 等于 c。

比较操作可以通过逻辑操作符 and 和 or 组合，比较的结果可以用 not 来取反义。这些操作符的优先级又低于比较操作符，
在他们之中， not 具有最高的优先级，or 优先级最低，所以A and not B or C 等于（A and (notB)) or C。当然，括号也可以
用于比较表达式。

逻辑操作符 and 和 or 也称为短路操作符：它们的参数从左向右解析，一旦结果可以确定就停止。例如，如果 A 和 C 为真而
B 为假，A and B and C 不会解析C。作用于一个普通的非逻辑值时，短路操作符的返回值通常是最后一个变量。

可以把比较或其它逻辑表达式的返回值赋给一个变量，例如：
\begin{minted}{python}
>>> string1, string2, string3 = '', 'Tronheim', 'Hammer Dance'
>>> non_null = string1 or string2 or string3
>>> non_null
'Tronheim'
\end{minted}

需要注意的是Python与C不同，在表达式内部不能赋值。C程序员经常对此抱怨，不过它避免了一类在C程序中司空见惯的错误：想要在解析式中使用==时误用了=操作符。

\subsection{比较序列和其它类型}
序列对像可以与相同类型的其它对象比较。比较操作按字典序进行：首先比较前两个元素，如果不同，就决定了比较的结果；
如果相同，就比较后两个元素，依此类推，直到所有序列都完成比较。如果两个元素本身就是同样类型的序列，就递归字典序比较。如果两个序列的所有子项都相等，就
认为序列相等。如果一个序列是另一个序列的初始子序列，较短的一个序列就小于另一个。字符串的字典序按照单字符的ASCII顺序。下面是同类型序列之间比较的一些例子：
\begin{minted}{python}
>>> (1, 2, 3)           < (1, 2, 4)
True
>>> [1, 2, 3]           < [1, 2, 4]
True
>>> 'ABC' < 'C' < 'Pascal' < 'Python'
True
>>> (1, 2, 3, 4)        < (1, 2, 4)
True
>>> (1, 2)              < (1, 2, -1)
True
>>> (1, 2, 3)           < (1.0, 2.0, 3.0)
False
>>> (1, 2, ('aa', 'ab'))        <(1, 2, ('abc', 'a'), 4)
True
\end{minted}

需要注意的是如果通过 $<$ 或者 $>$ 比较的对象只要具有合适的比较方法就是合法的。比如，混合数值类型是通过它们
的数值进行比较的，所以0等于0.0。否则解释器将会触发一个TypeError异常，而不是提供以和随意的结果。

\section{模块}
如果你退出Python解释器并重新进入，你做的任何定义（变量和方法）都会丢失。因此，如果你想要编写一些更大的程序，
为准备解释器输入使用一个文本编辑器会更好，并以那个文件替代作为输入执行。这就是传说中的脚本。随着你的程序变得越来越长，你可能想要将它
分割成几个更易于维护的文件。你也可能想在不同的程序中使用顺手的函数，而不是把代码在它们之间中考来拷去。

为了满足这些需要，Python提供了一个方法可以从文件中获取定义，在脚本或者解释器的一个交互式实例中使用。这样的文件被称为
模块；模块中的定义可以导入到另一个模块或主模块中（在脚本执行时可以调用的变量集位于最高级，并且处于计算器模式）。

模块是包括Python定义和声明的文件。文件名就是模块名加上 .py 后缀。模块的模块名（做为一个字符串）可以由全局变量
\_\_name\_\_ 得到。例如，你可以用自己惯用的文件编辑器在当前目录下创建一个叫 fibo.py 的文件，录入如下内容：
\begin{minted}{python}
# Fibonacci numbers module

def fib(n):        # write Fibonacci series up to n
    a, b = 0, 1
    while b < n:
        print(b, end=' ')
        a, b = b, a+b
    print()

def fib2(n):        # return Fibonacci series up to n
    result = []
    a, b = 0, 1
    while b < n:
        result.append(b)
        a, b = b, a+b
    return result
\end{minted}

现在进入Python解释器并使用以下命令导入模块：
\begin{minted}{python}
>>> import fibo
\end{minted}

这样做不会直接把 fibo 中的函数导入当前的语义表；它只是引入了模块名 fibo。你可以通过模块名按
如下方式访问这个函数：
\begin{minted}{python}
>>> fibo.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
>>> fibo.fib(100)
1 1 2 3 5 8 13 21 34 55 89
>>> fibo.__name__
'fibo'
\end{minted}

如果打算频繁使用一个函数，你可以将它赋予一个本地变量：
\begin{minted}{python}
>>> fib = fibo.fib
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
\end{minted}

\subsection{深入模块}
除了包含函数定义外，模块也可以包含执行语句。这些语句一般用来初始化模块。他们仅在第一次被导入的地方执行一次。

每个模块都有自己私有的符号表，被模块内所有的函数定义作为全局符号使用。因此，模块的作者可以在模块内部使用全局变量，
而无需担心它与某个用户的全局变量意外冲突。从另一个方面讲，如果你确切的知道自己在做什么，你可以使用引用模块函数的表示法
访问模块的全局变量， modname.itemname。

模块可以导入其他的模块。一个（好的）习惯是将所以的 import 语句放在模块的开始（或者是脚本），这并非强制。被导入命名到
本模块的语义表中。

import 语句的一个变体直接从被导入的模块中导入命名到本模块的语义表中。例如：
\begin{minted}{python}
>>> from fibo import fib, fib2
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
\end{minted}

这样不会从局域语义表中导入模块名（如上所示，fibo 没有定义）。

甚至有种方式可以导入模块中的所有定义：
\begin{minted}{python}
>>> from fibo import *
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
\end{minted}

这样可以导入所有除了以下划线（\_）开头的命名。

需要注意的是在实践中往往不鼓励从一个模块或包中使用\*导入所有，因为这样会让代码变得很难读。不过，在交互式会话中这样用很方便省力。

注意：出于性能考虑，每个模块在每个解释器会话中只导入一遍。因此，如果你修改了你的模块，需要重启解释器；或者，如果你就是想
交互式的测试这么一个模块，可以用imp.reload()重新加载，例如： import imp: imp.reload(modulename)。

\subsubsection{作为脚本来执行模块}
当你使用以下方式运行Python模块时，模块中的代码便会被执行：
\begin{minted}{python}
>>> python fibo.py <arguments>
\end{minted}

模块中的代码会被执行，就像导入它一样，不过此时 \_\_name\_\_ 被设置为 ``\_\_main\_\_''。这相当于，
如果你在模块后加入代码：
\begin{minted}{python}
if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))
\end{minted}

就可以让文件像作为模块导入时一样作为脚本执行。此代码只有在模块作为``mian''文件执行时才被调用：
\begin{minted}{python}
lujingyu $ python fibo.py 50
1 1 2 3 5 8 13 21 34
\end{minted}

如果模块被导入，不会执行这段代码：
\begin{minted}{python}
>>> import fibo
>>>
\end{minted}

这通常用来为模块提供一个便于测试的用户接口（将模块作为脚本执行测试需求）。

\subsubsection{模块的搜索路径}
导入一个叫 spam 的模块时，解释器先在当前目录中搜索名为 spam.py 的文件。
如果没有找到的话，接着会到sys.path变量中给出的目录列表中查找。sys.path变量的初始化值来自如下：
\begin{itemize}
  \item 输入脚本的目录（当前目录）。
  \item 环境变量PYTHONPATH表示的目录列表中搜索（这和shell变量PATH具有一样的语法，即一系列目录名的列表）。
  \item Python 默认安装路径中搜索。
\end{itemize}

注释：在支持符号连接的文件系统中，输入的脚本所在的目录是符号链接指向的目录。换句话说也就是包含符号链接的目录不会
被加到目录搜索路径中。

实际上解释器由sys.path变量指定的路径目录搜索模块，该变量初始化时默认包含了输入脚本（或者当前目录），
PYTHONPATH和安装目录。这样就允许Python程序了解如何修改或替换模块搜索目录。需要注意的是由于这些目录中包含有搜索路径中运行的脚本，
所以这些脚本不应该和标准模块重名，否则在导入模块时Python会尝试把这些脚本当做模块来加载。这通常会引发错误。

\subsubsection{"编译的"Python文件}
为了加快加载模块的速度，Python 会在 \_\_pycache\_\_ 目录下以 module.version.pyc 名字缓存每个模块编译后的版本，
这里的版本编制了编译后文件的格式。它通常会包含 Python 的版本号。例如，在 CPython 3.3 版中，
spam.py 编译后的版本将缓存为 \_\_pycache\_\_\/spam.cpython\-33.pyc。
这种命名约定允许由不同发布和不同版本的 Python 编译的模块同时存在。

Python 会检查源文件与编译版的修改日期以确定它是否过期并需要重新编译。
这是完全自动化的过程。同时，编译后的模块是跨平台的，所以同一个库可以在不同架构的系统之间共享。

Python 不检查在两个不同环境中的缓存。首先，它会永远重新编译而且不会存储直接从命令行加载的模块。
其次，如果没有源模块它不会检查缓存。若要支持没有源文件（只有编译版）的发布，
编译后的模块必须在源目录下，并且必须没有源文件的模块。

部分高级技巧:
\begin{itemize}
  \item 为了减少一个编译模块的大小，你可以在Python命令行中使用 \-O 或者 \-OO。\-O参数删除了断言语句，
  \-OO参数删除了断言语句和\_\_doc\_\_字符串。

  因为某些程序依赖因为某些程序依赖于这些变量的可用性，你应该只在确定无误的场合使用这一选项。
  “优化的” 模块有一个 .pyo 后缀而不是 .pyc 后缀。未来的版本可能会改变优化的效果。
  \item 来自 .pyc 文件或 .pyo 文件中的程序不会比来自 .py 文件的运行更快；.pyc 或 .pyo 文件只是在它们加载的时候更快一些。
  \item compileall 模块可以为指定目录中的所有模块创建 .pyc 文件（或者使用 -O 参数创建 .pyo 文件）。
\end{itemize}

\subsection{标准模块}
Python带有一个标准模块库，并发布由独立的文档，名为Python库参考手册（此后称其为``库参考手册''）。
有一些模块内置于解释器之中，这些操作的访问接口不是语言内核的一部分，但是已经内置于解释器了。这既是为了提高效率
，也是为了给系统调用等操作系统原生访问提供接口。这类模块集合是一个依赖于底层平台的配置选项。
例如，winreg模块只提供在Windows系统上才有。有一个具体的模块值得注意：sys，这个模块内置于所有的Python
解释器。变量sys.ps1和sys.ps2定义可主提示符和辅助提示符字符串：
\begin{minted}{python}
>>> import sys
>>> sys.ps1
'>>> '
>>> sys.ps2
'... '
>>> sys.ps1 = 'C>'
C> print('Yuck!')
Yuck!
C>
\end{minted}

这两个变量只在解释器的交互模式下有意义。

变量sys.path是解释器模块搜索路径的字符串列表。它由环境变量PYTHONPATH 初始化，
如果没有设定 PYTHONPATH ，就由内置的默认值初始化。你可以用标准的字符串操作修改它:
\begin{minted}{python}
>>> import sys
>>> sys.path.append('ufs/guido/lib/python')
\end{minted}
\subsection{dir()函数}
内置函数dir()用于按模块名搜索块定义，它返回一个字符串类型的存储列表：
\begin{minted}{python}
>>> import fibo, sys
>>> dir(fibo)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__',

'__package__', '__spec__', 'fib', 'fib2']
>>> dir(sys)
['__displayhook__', '__doc__', '__excepthook__', '__interactivehook__', '__loader__',

'__name__', '__package__','__spec__', '__stderr__', '__stdin__', '__stdout__',

'_clear_type_cache', '_current_frames', '_debugmallocstats', '_getframe',

'_git', '_home', '_xoptions', 'abiflags', 'api_version', 'argv', 'base_exec_prefix',

'base_prefix', 'builtin_module_names', 'byteorder','call_tracing', 'callstats',

'copyright', 'displayhook', 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix',

'executable', 'exit','flags', 'float_info', 'float_repr_style', 'get_asyncgen_hooks',

'get_coroutine_wrapper', 'getallocatedblocks', 'getcheckinterval','getdefaultencoding',

 'getdlopenflags', 'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile',

 'getrecursionlimit', 'getrefcount','getsizeof', 'getswitchinterval', 'gettrace',

 'hash_info', 'hexversion', 'implementation', 'int_info', 'intern', 'is_finalizing', 'maxsize',

'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache', 'platform',

 'prefix', 'ps1', 'ps2', 'set_asyncgen_hooks','set_coroutine_wrapper', 'setcheckinterval',

 'setdlopenflags', 'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr',

'stdin', 'stdout', 'thread_info', 'version', 'version_info', 'warnoptions']
\end{minted}

无参调用时，dir()函数返回当前定义的命名：
\begin{minted}{python}
>>> a = [1, 2, 3, 4, 5]
>>> import fibo
>>> fib = fibo.fib
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__',

'__name__', '__package__', '__spec__', 'a', 'fib', 'fibo', 'sys']
\end{minted}

注意该列表列出了所有类型的名称：变量，模块，函数，等等。

dir()不会列出内置函数和变量名。如果你想列出这些内容，它们在标准模块builtins中定义：
\begin{minted}{python}
>>> import builtins
>>> dir(builtins)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError',

'BrokenPipeError', 'BufferError','BytesWarning', 'ChildProcessError', 'ConnectionAbortedError',

'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError','DeprecationWarning',

'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError',

'FileNotFoundError','FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError',

'ImportError', 'ImportWarning','IndentationError', 'IndexError','InterruptedError',

'IsADirectoryError', 'KeyError', 'KeyboardInterrupt','LookupError', 'MemoryError',

'ModuleNotFoundError', 'NameError','None', 'NotADirectoryError','NotImplemented',

'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning',

'PermissionError','ProcessLookupError', 'RecursionError', 'ReferenceError',

'ResourceWarning', 'RuntimeError', 'RuntimeWarning','StopAsyncIteration', 'StopIteration',

'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit','TabError', 'TimeoutError',

'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError','UnicodeEncodeError',

'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError',

'Warning', 'ZeroDivisionError', '_','__build_class__', '__debug__', '__doc__',

'__import__', '__loader__', '__name__', '__package__', '__spec__','abs', 'all', 'any',

'ascii', 'bin','bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod',

'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod',

'enumerate', 'eval','exec', 'exit', 'filter', 'float', 'format', 'frozenset',

'getattr', 'globals', 'hasattr', 'hash','help', 'hex', 'id','input', 'int',

'isinstance', 'issubclass', 'iter', 'len', 'license', 'list','locals', 'map',

'max', 'memoryview', 'min', 'next', 'object','oct', 'open', 'ord', 'pow',

'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr',

'slice', 'sorted','staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']
\end{minted}

\subsection{包}
包通常是使用用"圆点模块名"的结构化模块命名空间。例如，名为 A.B的模块表示了名为A的包中名为B的子块。正如同用
模块来保存不同的模块架构可以避免全局变量之间的相互冲突，使用圆点模块名保存像 NumPy 或 Python Imaging Library
之类的 不同类库架构可以避免模块之间的明明冲突。

假设你现在想要设计一个模块集（一个``包''）来统一处理声音文件和声音数据。存在几种不同的声音格式
（通常由他们的扩展名来标识，例如：.wav, .aiff, .au），于是，为了在不同类型的文件格式之间转换，你需要维护一个不断增长
的包集合。可能你还想要对声音数据做很多不同的操作（例如混音，添加回声，应用平衡 功能，创建一个人造效果），
所以你要加入一个无限流模块来执行这些操作。你的包可能会是这个样子（通过分级的文件体系来进行分组）:
\begin{minted}{python}
sound/                          Top-level package
      __init__.py               Initialize the sound package
      formats/                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Subpackage for sound effects
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Subpackage for filters
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
\end{minted}

当导入这个包时，Python 通过 sys.path搜索路径查找包含这个包的子目录。

为了让Python将目录当做内容包，目录中必须包含\_\_init\_\_.py文件。这是为了避免一个含有烂俗名字
的目录无意中隐藏了稍后在模块中出现的有效模块，比如string。虽简单的情况下，只需要一个空的\_\_init\_\_.py
文件即可。当然他也可以执行包的初始化代码，或者定义稍后介绍的\_\_all\_\_变量。

用户可以每次只导入包里的特定模块，例如：

import sound.effects.echo


这样就导入了 sound.effectd.echo 子模块。它必须通过完整的名称来引用：
\begin{minted}{python}
sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
\end{minted}

导入包时有一个可以选择的方式：
\begin{minted}{python}
from sound.effectd import echo
\end{minted}

这样就加载了echo子模块，并且使得它在没有包前缀的情况下也可以使用，所以它可以如下方式调用：
\begin{minted}{python}
echo.echofilter(input, output, delay=0.7, atten=4)
\end{minted}

还有另一种变体用于直接导入函数或变量:
\begin{minted}{python}
from sound.effects.echo import echofilter
\end{minted}

这样就又一次加载了 echo 子模块，但这样就可以直接调用它的 echofilter() 函数：
\begin{minted}{python}
echofilter(input, output, delay=0.7, atten=4)
\end{minted}

需要注意的是使用 from package import item 方式导入包时，这个子项（item）既可以是包中的一个子模块（或一个子包），
也可以是包中定义的其它命名，像函数、类或变量。
import 语句首先核对是否包中有这个子项，如果没有，它假定这是一个模块，并尝试加载它。如果没有找到它，会引发一个 ImportError 异常。

相反，使用类似 import item.subitem.subsubitem 这样的语法时，这些子项必须是包，最后的子项可以是包或模块，
但不能是前面子项中定义的类、函数或变量。

\subsubsection{从*导入包}
当用户写下from sound.effects import \* 时会发生什么事？理想中，总是希望在文件系统中找出包中所有的子模块，
然后导入它们。这可能会花掉很长时间，并且出现期待之外的边界效应，导出了希望只能显示导入的包。

对于包的作者来说唯一的解决方案就是提供一个明确的包索引。import语句按如下条件进行转换：执行 from package import \*  时，如果包中的
\_\_init\_\_.py 代码定义了一个名为\_\_all\_\_的列表，就会按照列表中给出的模块名进行导入。新版本的包发布时作者可以任意更新这个列表。
如果包作者不想import\*的时候导入他们的包中所有模块,那么也可能会决定不支持它（import\*）。例如，sound/effects/\_\_init\_\_.py
这个文件可能包括如下代码：
\begin{minted}{python}
 __all__ = ["echo", "surround", "reverse"]
\end{minted}

这意味着 from sound.effects import \* 语句会从 sound 包中导入以上三个已命名的子模块。

如果没有定义\_\_all\_\_, from sound.effects import \* 语句不会从 sound.effects包中导入所有的子模块。
无论包中定义多少命名，只能确定的是导入了sound.effects包（可能会运行\_\_init\_）
每一个命名（以及明确导入的子模块）。同样也包括了前述的import语句从包中明确导入的子模块，考虑以下代码：
\begin{minted}{python}
  import sound.effects.echo
  import sound.effects.surround
  from sound.effects import *
\end{minted}

这个例子中, echo和surround 模块导入了当前的命名空间，这是因为执行 from...import语句时它们已经定义在sound.effects包中了（定义了\_\_all\_\_
时也会同样工作）。

尽管某些模块设计为使用 import *时它只导出符合某种规范/模式的命名，仍然不建议在产生代码中使用这种方法。

记住， from package import specific\_submodule没有错误！事实上，除非导入的模块需要使用其它包中的同名子模块，否则这是推荐的写法。
\subsubsection{包内引用}
如果包中使用了子包结构（就像示例中的sound包），可以按绝对位置从相邻的包中引入子模块。例如，如果sound.filters.vovoder包需要使用 sound.effects
包中的echo模块，它可以from sound.Effects import echo。

你可以用这样的形式from module import name来写显示的相对位置导入。那些显式相对导入用点号标明关联导入当前和上级包。以surround模块为例，你可以这样用：
\begin{minted}{python}
from . import echo
from .. import formats
from ..filters import equalizer
\end{minted}

需要注意的是显式或隐式相对位置导入都基于当前模块的命名。因为主模块的名字总是``\_\_name\_\_'',Python应用程序的主模块应该总是用绝对导入。

\subsubsection{多重目录中的包}
包支持一个更为特殊的特性，\_\_path\_\_。在包的\_\_init\_\_.py文件代码执行之前，该变量初始化一个目录名列表。改变量可以修改，
它作用于包中的子包和模块的搜索功能。

这个功能可以用于扩展包中的模块集，不过它不常用。
\section{输入输出}
一个程序可以有几种输出方式：以人类可读的方式打印数据，或者写入一个文件供以后使用。文章将讨论几种可以能性。
\subsection{格式化输出}
我们有两种大相径庭地输出值方法：表达式语句和print()函数（第三种访求是使用文件对象的 write() 方法，标准文件输出可以参考 sys.stdout,
详细内容参见手册）。

通常，你想要对输出做更多的格式控制，而不是简单的打印使用空格分隔的值。有两种方法可以格式化你的输出：第一种方法是由你自己处理整个字符串，
通过使用字符串切割和连接操作可以创建任何你想要的输出形式。string类型包含一些将字符串填充到指定列宽度的有用操作，随后就会讨论这些。
第二种方法是使用str.format()方法 。

标准模块string包括了一些操作，将字符串填充入给定列时，这些操作很有用。随后我们会讨论这部分内容。第二种方法是使用Template方法。

当然，还有一个问题，如何将值转化为字符串？很幸运，Python有办法将任意值转为字符串：将它传入 repr()或str()函数。

函数str()用于将值转化为适于阅读的形式，而repr()转化为供解释器读取的形式（如果没有等价的语法，则会发生SyntaxError异常）
某对象没有适于人阅读的解释形式的话，str()会返回与repr()等同的值。很多类型，诸如数值或链表、字典这样的结构，
针对各函数都有着统一的解读方式。字符串和浮点数，有着独特的解读方式。
\begin{minted}{python}
>>> s = 'Hello, world.'
>>> str(s)
'Hello, world.'
>>> repr(s)
"'Hello, world.'"
>>> str(1/7)
'0.14285714285714285'
>>> x = 10 * 3.25
>>> y = 200 * 200
>>> s = 'The value of x is ' + repr(x) + ', and y is' + repr(y) + '...'
>>> print(s)
The value of x is 32.5, and y is40000...
>>> # The repr() of a string adds string quotes and backlashes:
... hello = 'hello, world\n'
>>> hellos = repr(hello)
>>> print(hellos)
'hello, world\n'
>>> # The argument to repr() may be any Python object:
... repr((x, y, ('spam', 'eggs')))
"(32.5, 40000, ('spam', 'eggs'))"
\end{minted}

有两种方式可以写平方和立方表：
\begin{minted}{python}
>>> for x in range(1, 11):
...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')
...     # Note use of 'end' on previous line
...     print(repr(x*x*x).rjust(4))
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
>>> for x in range(1, 11):
...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
\end{minted}

(注意第一个例子，print()在每列之间加了一个空格，它总是在参数间加空格。)

以上是一个str.rjust()方法的演示，它把字符串输出到一列，并通过向左侧填充空格来使其右对齐。
类似的方法还有str.ljust()和str.center()。这些函数只是输出新的字符串，并不改变什么。如果输出
的字符串太长，它们也不会截断它，而是原样输出，这会使你的输出格式变得混乱，不过总强过另一种选择（
截断字符串），因为那样会产生错误的输出值（如果你确实需要截断它，可以使用切割操作，例如：x.lijust(n)
[:n]）。

还有另一个方法，str.zfill()它用于向数值的字符串表达左侧填充0。该函数可以正确理解正负号：
\begin{minted}{python}
>>> '12'.zfill(5)
'00012'
>>> '-3.14'.zfill(7)
'-003.14'
>>> '3.14159265359'.zfill(5)
'3.14159265359'
\end{minted}

方法 str.format()的基本用法如下：
\begin{minted}{python}
>>> print('We are the {} who say "{}!"'.format('knights', 'Ni'))
We are the knights who say "Ni!"
\end{minted}

大括号和其中的字符会被替换成传入str.format()的参数。大括号中的数值指明使用传入str.format()
方法的对象中的哪一个：
\begin{minted}{python}
>>> print('{0} and {1}'. format('spam', 'eggs'))
spam and eggs
>>> print('{1} and {0}'. format('spam', 'eggs'))
eggs and spam
\end{minted}

如果在str.format()调用时使用关键字参数，可以通过参数名来引用值:
\begin{minted}{python}
>>> print('This {food} is {adjective}.'.format(
...     food='spam', adjective='absolutely horrible'))
This spam is absolutely horrible.
\end{minted}

位置参数和关键字参数可以随意组合：
\begin{minted}{python}
>>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred', other='Georg'))
The story of Bill, Manfred, and Georg.
\end{minted}

`!a'(应用ascii()), `!s'(应用str())和 `!r'(应用repr())可以在格式化之前转换值：
\begin{minted}{python}
>>> import math
>>> print('The value of PI is approximately {}.'.format(math.pi))
The value of PI is approximately 3.141592653589793.
>>> print('The value of PI is approximately {!r}.'.format(math.pi))
The value of PI is approximately 3.141592653589793.
\end{minted}

字段名后允许可选的`:'和格式指令。这允许对值的格式化加以更深入的控制。下列将P转为三位精度。
\begin{minted}{python}
>>> print('The value of PI is approximately {0:.3f}.'.format(math.pi))
The value of PI is approximately 3.142.
\end{minted}

在字段后的`:'后面加一个整数会限定该字段的最小宽度，这在美化表格时很有用：
\begin{minted}{python}
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
>>> for name, phone in table.items():
...     print('{0:10} ==> {1:10d}'.format(name, phone))
...
Sjoerd     ==>       4127
Jack       ==>       4098
Dcab       ==>       7678
\end{minted}

如果你有个实在是很长的格式化字符串，不想分割它。如果你可以用命名来引用被格式化的变量而不是位置就好了。
有个简单的方法，可以传入一个字典，用中括号（`[]'）访问它的键：
\begin{minted}{python}
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
>>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))
Jack: 4098; Sjoerd: 4127; Dcab: 8637678
\end{minted}

这种方式与新的内置函数vars()组合使用非常有效。该函数返回包含所有局部变量的字典。

要更进一步了解字符串格式化方法str.format(),参见格式字符串语法。

\subsubsection{旧式的字符串格式化}
操作符\%也可用于字符串格式化。它以类似sprintf()-style的方式解析左参数，将右参数应用于此，得到格式化操作生成的字符串，例如：
\begin{minted}{python}
>>> import math
>>> print('The value of PI is approximately %5.3f.'% math.pi)
The value of PI is approximately 3.142.
\end{minted}

\subsection{文件读写}
函数open()返回文件对象，通常的用法需要两个参数：open(filename, mode)。
\begin{minted}{python}
>>> f = open('workfile', 'w')
\end{minted}

第一个参数是一个含有文件名的字符串。第二个参数也是一个字符串，含有描述如何使用该文件的几个字符。
mode为`r'时表示只是读取文件；`w'表示只是写入文件（已经存在的同名文件将被删掉）；`a'表示打开文件进行
追加，写入到文件中的任何数据将自动添加到末尾。`r+'表示打开文件进行读取和写入。mode参数是可选的，默认为`r'。

通常，文件以文本打开，这意味着，你从文件读出和向文件写入的字符串会被特定的编码方式（默认是UTF-8）
编码。模式后面的`b'以二进制模式打开文件：数据会以字节对象的形式读出和写入。这种模式应该用于所有不包含文本的文件。

在文本模式下，读取时默认会将平台有关的行结束符（Unix上是 \textbackslash n , Windows上是 \textbackslash r\textbackslash n）转换为 \textbackslash n。
在文本模式下写入时，默认会将出现的 \textbackslash n 转换成平台有关的行结束符。
这种暗地里的修改对 ASCII 文本文件没有问题，但会损坏 JPEG 或 EXE 这样的二进制文件中的数据。使用二进制模式读写此类文件时要特别小心。

\subsubsection{文件对象方法}
示例默认文件对象f已经创建。

要读取文件内容，需要调用f.read(size),该方法读取若干数量的数据并以字符串形式返回其内容，size是可选的数值，指定字符串长度。如果没有指定size或者指定为负数，
就会读取返回整个文件。当文件大小为当前机器内存两倍时，就会产生问题。反之，会尽可能按比较大的size读取和返回数据。如果到了文件末尾，f.read()会返回一个空字符串
（` '）:
\begin{minted}{python}
>>> f = open('workfile')
>>> f.read()
'This is the entire file.\n'
>>> f.read()
''
\end{minted}

f.readline() 从文件中读取单独一行，字符串结尾会自动加上一个换行符（\textbackslash n），入过当文件最后一行没有以换行符结尾时，
这一操作才会被忽略。这样返回值就不会有混淆，如果f.readline()返回一个空字符串，那就表示到达了文件末尾，如果是一个空行，就会描述为`\textbackslash n'
，一个只包含换行符的字符串：
\begin{minted}{python}
>>> f.readline()
'This is the entire file.\n'
>>> f.readline()
'Second line of the file.\n'
>>> f.readline()
''
\end{minted}

你可以循环遍历文件对象来读取文件中的每一行。这是一种内存高效、快速，并且代码简介的方法：
\begin{minted}{python}
>>> f = open('workfile')
>>> for line in f:
...     print(line, end='')
...
This is the entire file.
Second line of the file.
\end{minted}

如果你想把文件中的所有行读到一个列表中，你也可以使用list(f)或者f.readlines()。

f.write(string)方法将string的内容写入文件，并返回写入字符的长度：
\begin{minted}{python}
>>> f = open('workfile', 'w')
>>> f.write('This is a test\n')
15
\end{minted}

想要写入其他非字符串内容，首先要将它转换为字符串：
\begin{minted}{python}
>>> value = ('the answer', 42)
>>> s = str(value)
>>> f.write(s)
18
\end{minted}

f.tell()返回一个整数，代表文件对象在文件中的指针位置，该数值计量了自文件开头到指针处的比特数。需要改变文件对象指针，
使用f.seek(offset,from\_what)。指针在该操作中从指定的引用位置移动offset比特，引用位置由from\_what参数指定。from\_what
值为0表示自文件起始处开始，1表示自当前文件指针位置开始，2表示自文件末尾开始。from\_what可以忽略，其默认值为0，此时从文件头开始：
\begin{minted}{python}
>>> f = open('workfile', 'rb+')
>>> f.write(b'0123456789abcdef')
16
>>> f.seek(5)      # Go to the 6th byte in the file
5
>>> f.read(1)
b'5'
>>> f.seek(-3, 2) # Go to the 3rd byte before the end
30
>>> f.read(1)
b'4'
\end{minted}

在文本文件中（没有以 b模式打开），只允许从文件头开始寻找（有个例外是用seek(0,2)寻找
文件的最末尾处）而且合法的偏移值只能是f.tell()返回的值或者是零。其它任何偏移值都会产生未定义的行为。

当你使用完一个文件时，调用f.close()方法就可以关闭它并释放其占用的所有系统资源。在调用f.cloae()方法后，
试图再次使用文件对象将会自动失败。
\begin{minted}{python}
>>> f.close()
>>> f.read()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: read of closed file
\end{minted}

用关键字with处理文件对象是个好习惯。它的先进之处在于文件用完后会自动关闭，就算发生异常也没关系。
它是 try-finally块的简写：
\begin{minted}{python}
>>> with open('workfile', 'r') as f:
...     read_data = f.read()
>>> f.closed
True
\end{minted}

文件对此昂还有一些不太常用的附加方法，比如isatty()和trucate()在库参考手册中有文件对象
的完整指南。

\subsubsection{使用json存储结构化数据}
从文件中读写字符串很容易。数值就要多费点周折，因为read()方法只会返回字符串，应将其传入int()这样的函数，
就可以将`123' 这样的字符串转换为对应的数值123。当你想要保存更为复杂的数据类型，例如嵌套的列表和字典，手工解析和序列化它们将变得更为复杂。

好在用户不是非得自己编写和调试保存复杂数据类型的代码，Python允许你使用常用的数据交换格式 JSON(JavaScript Object Notation)。
标准模块json可接受Python数据结构，并将它们转换为字符串表示形式；此过程称为序列化。从字符串表示形式重新构建数据结构称为反序列化。
序列化和反序列化的过程中，表示该对象的字符串可以存储在文件或数据中，也可以通过网络连接传送给远程的机器。

注解：JSON格式经常用于现代应用程序中进行数据交换。许多程序员都已经熟悉它了，使它成为相互协作的一个不错的选择。

如果你有一个对象 x，你可以用简单的一行代码查看其JSON字符串表示形式：
\begin{minted}{python}
>>> json.dumps([1, 'simple', 'list'])
'[1, 'simple', 'list']'
\end{minted}

dumps()函数的另外一个变体dunp()，直接将对象序列化到一个文件。所以如果f是为写入而打开的一个文件对象，我们可以这样做：
\begin{minted}{python}
json.dump(x, f)
\end{minted}

为了重新解码对象，如果f是为读取而打开的文件对象：

x = json.load(f）

这种简单的序列化技术可以处理列表和字典，但序列化任意类实例为JSON需要一点额外的努力。json模块的手册对此有详细的解释。

参见：pickle-pickle模块 与JSON不同，pickle是一个协议，它允许任意复杂的Python对象的序列化。因此，它只能用于Python
而不能用来与其他语言编写的应用程序进行通信。默认情况下它也是不安全的：如果数据由熟练的攻击者精心设计，反序列化来自一个
不守信任源的pickle数据可以执行任意代码。

\section{错误和异常}
至今为止还没有进一步的谈论过错误信息，不过在你已经试验过的那些例子中，可能已经遇到过一些。
Python中（至少）有两种错误：语法错误和异常（syntax errors和exceptions)。
\subsection{语法错误}
语法错误，也被称作解析错误，也许是你学习Python过程中最常见抱怨：
\begin{minted}{python}
>>> while True print('Hello world')
  File "<stdin>", line 1, in ?
    while True print('Hello world')
                   ^
SyntaxError: invalid syntax
\end{minted}

语法分析器指出错误行，并且在检测到错误的位置前面显示一个小箭头。错误是由箭头前面的标记引起的（或者至少是这么监测的）
：这个例子中，函数print()被发现存在错误，因为它前面少了一个冒号（`:'）。错误会输出文件名和行号，所以如果是从脚本输入
的你就知道去哪里检查错误了。

\subsection{异常}
即使一条语句或表达式在语法上是正确的，当试图执行它时也可能会引发错误。运行期检测到错误称为异常，并且程序不会无条件的崩溃：
很快，你将学到如何在Python程序中处理它们。然而，大多数异常都不会被程序处理，向这里展示的一样最终会产生一错误信息。
异常也有不同的类型，异常类型做为错误信息的一部分显示出来：
示例中的异常分别为 零除错误（ ZeroDivisionError ） ，命名错误（ NameError） 和 类型错误（ TypeError ）。
\subsection{异常处理}
通过编程处理选择的异常是可行的。看一下下面的例子：它会一直要求用户输入，直到输入一个合法的整数为止，但允许用户中断这个程序
（使用 Control-C 或系统支持的任何方法）。注意：用户产生的中断会引发一个 KeyboardInterrupt 异常。
\begin{minted}{python}
>>> while True:
...     try:
...             x = int(input("Please enter a number: "))
...             break
...     except ValueError:
...             print("Oops! That was no valid number. Try again...")
...
\end{minted}

try语句按如下方式工作。
\begin{itemize}
  \item 首先，执行try子句（在try和except关键字之间的部分）。
  \item 如果没有异常发生，except子句在try语句执行完毕后就被忽略了。
  \item 如果在try子句执行过程中发生了异常，那么该子句其余部分就会被忽略。

  如果异常匹配于 except关键字后面指定的异常类型，就执行对应的except子句。然后继续执行try语句之后的代码。
  \item 如果发生了一个异常，在except子句中没有与之匹配的分支，它就会传递到上一级try语句中。

  如果最终仍找不到对应的处理语句，它就成为一个未处理异常，终止程序运行，显示提示信息。
\end{itemize}

\section{类}
Python的类机制通过最小的新语法和语义在语言中实现了类。它是C++或者Modula-3语言中类机制的混合。
就像模块一样，Python的类并没有在用户和定义之间设立绝对的屏障，而是依赖于用户不去``强行闯入定义''的优雅。
另一方面，另一方面，类的大多数重要特性都被完整的保留下来：类继承机制允许多重继承，派生类可以覆盖（override）基类中的任何方法或类，
可以使用相同的方法名称调用基类的方法。对象可以包含任意数量的私有数据。
\subsection{术语相关}
对象具有特性，并且多个名称（在多个作用域中）可以绑定在同一个对象上。在其它语言中被称为别名。在对Python的第一印象中这通常会被忽略
并且当处理不可变基础类型（数字，字符串，元组）时可以被放心的忽略。但是，在调用列表、字典这类可变对象，或者大多数程序外部类型
（文件，窗体等）描述实体时，别名对 Python 代码的语义便具有（有意而为）影响。这通常有助于程序的优化，
因为在某些方面别名表现的就像是指针。例如，你可以轻易的传递一个对象，因为通过继承只是传递一个指针。并且如果一个方法修改了一个作为参数传递的对象，
调用者可以接收这一变化——这消除了两种不同的参数传递机制的需要，像 Pascal 语言。
\subsection{Python作用域和命名空间}
命名空间是从命名到对象的映射。当前命名空间主要是通过Python字典实现的，不过通常不关心具体的实现方式（除非出于性能考虑），以后也有可能
会改变其实现方式。以下有一些命名空间的例子：内置命名（像abs()这样的函数，以及内置异常名）集，模块中的全局命名，函数调用中的局部命名。某种
意义上讲对象的属性集也是一个命名空间。关于命名空间需要了解一件很重要的事就是不同命名空间中的命名没有任何联系，例如两个不同的模块可能都会定义一个名为maximize
的函数而不会发生混淆-用户必须以模块名为前缀来引用它们。

顺便提一句，我称Python中任何一个``.''之后的命名为属性 --例如，表达式z.real中的real是对象z的一个属性。严格来讲，从模块中引用命名是引用属性：
表达式modname.funcname中，nodname是一个模块对象，funcname是它的一个属性。因此，模块的属性和模块中的全局命名有直接的映射关系：他们共享同一命名
空间。

属性可以是只读过或写的。后一种情况下，可以对属性赋值。你可以这样作：modname.the\_answer = 42。可写的属性也可以用del语句删除。
例如：del modname.the\_answer会从modname对象中删除the\_answer属性。

作用域 就是一个 Python 程序可以直接访问命名空间的正文区域。这里的直接访问意思是一个对名称的错误引用会尝试在命名空间内查找。尽管作用域是静态定义，
在使用时他们都是动态的。每次执行时，至少有三个命名空间可以直接访问的作用域嵌套在一起：
\begin{itemize}
  \item 包含局部命名的使用域在最里面，首先被搜索；其次搜索的是中层的作用域，这里包含了统计函数；

  最后搜索最外面的作用域，它包含内置命名。
  \item 首先搜索最内层的作用域，它包含局部命名任意函数包含的作用域，是内层嵌套作用域搜索起点，包含非局部，但是也非全局的命名
  \item 接下来的作用与包含当前模块的全局命名
  \item 最外层的作用域（最后搜索）是包含内置命名空间
\end{itemize}

如果一个命名声明为全局的，那么对它的所有引用和赋值会直接搜索包含这个模块全局命名的作用域。如果要重新绑定最里层作用域之外的变量，可以使用 nonlocal 语句；
如果不声明为 nonlocal，这些变量将是只读的（对这样的变量赋值会在最里面的作用域创建一个新的局部变量，外部具有相同命名的那个变量不会改变）。

Python 的一个特别之处在于：如果没有使用 global 语法，其赋值操作总是在最里层的作用域。赋值不会复制数据，只是将命名绑定到对象。
删除也是如此：del x 只是从局部作用域的命名空间中删除命名 x 。事实上，所有引入新命名的操作都作用于局部作用域。特别是 import 语句和函数定义将模块名或函数绑定于局部作用域
（可以使用 global 语句将变量引入到全局作用域）。

global 语句用以指明某个特定的变量为全局作用域，并重新绑定它。nonlocal 语句用以指明某个特定的变量为封闭作用域，并重新绑定它。
\subsubsection{作用域和命名空间示例}
以下是一个示例，演示了如何引用不同作用域和命名空间，以及global 和 nonlocal 如何影响变量绑定：
\begin{minted}{python}
def scope_test():
...     def do_local():
...             spam = "local spam"
...     def do_nonlocal():
...             nonlocal spam
...             spam = "nonlocal spam"
...     def do_global():
...             global spam
...             spam = "global spam"
...     spam = "test spam"
...     do_local()
...     print("After nonlocal assignment:", spam)
...     do_nonlocal()
...     print("After global assignment:", spam)
... scope_test()
... print("In global scope:", spam)
\end{minted}

以上示例代码的输出为：
\begin{minted}{python}
After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
\end{minted}

注意：local 赋值语句是无法改变 scope\_test 的 spam 绑定。nonlocal 赋值语句改变了
scope\_test 的 spam 绑定，并且 global 赋值语句从模块级改变了 spam 绑定。

你也可以看到在 global 赋值语句之前对 spam 是没有预先绑定的。

\subsection{初识类}
引入了一些新语法：三种新的对象类型和一些新的语义。
\subsubsection{类定义语法}
类定义最简单的形式如下：
\begin{minted}{python}
class ClassName:
  <statement-1>
  .
  .
  .
  <statement-N>
\end{minted}

类的定义（def语句），要先执行才能生效。（你当然可以把它放进if语句的某一分支，或者一个函数的内部。）

进入类定义部分后，会创建出一个新的命名空间，作为局部作用域。因此，所有的赋值成为这个新命名空间的
局部变量。特别是函数定义在此绑定了新的命名。

定义完成时（正常退出），就创建了一个类对象。基本上它是对类定义创建的命名空间进行了一个包装；我们在下一节进一步学习类对象的知识。
原始的局部作用域（类定义引入之前生效的那个）得到恢复，类对象在这里绑定到类定义头部的类名（例子中是ClassName）。
\subsubsection{类对象}
类对像支持两种操作：属性引用和实例化。

属性引用使用和Python中所有的属性引用一样的标准语法：obj.name。类对象创建后，类名空间中所有的命名都是有效属性名。所以
如果类定义是这样：
\begin{minted}{python}
>>> class MyClass:
...     """A simple example class"""
...     i = 12345
...     def f(self):
...             return 'hello world'
\end{minted}

那么MyClass.i和MyClass.f是有效的属性应用，分别返回一个整数和一个方法对象。也可以对类属性赋值，你可以通过给MyClass.i赋值来修改
它。\_\_doc\_\_也是一个有效的属性，返回类的文档字符串：``A simple example class''。

类的实例化使用函数符号。只要将类对像看做是一个返回新的类实力的无参数函数即可。例如（假设沿用前面的类）：
\begin{minted}{python}
x = MyClass()
\end{minted}

以上创建了一个新的类 实例并将该对象赋给局部变量x。

这个实例化操作（``调用''一个类对象）来创建一个空的对象。很多类都倾向于将对象创建为有初始状态的。
因此类可能会定义一个名为可能会定义一个名为\_\_inti\_\_()的特殊方法，像下面这样：
\begin{minted}{python}
def __init__(self):
    self.data = []
\end{minted}

类定义了\_\_init\_\_()方法的话，类的实例化操作会自动为新创建的类实例调用\_\_init\_\_()方法。
所以在下例中，可以这样创建一个新的实例：
\begin{minted}{python}
x = MyClass()
\end{minted}

当然，出于弹性的需要，\_\_inti\_\_()方法可以有参数。事实上，参数通过\_\_inti\_\_()传递到类的实例化操作上。
例如，
\begin{minted}{python}
>>> class Complex:
...     def __init__(self, realpart, imagpart):
...             self.r = realpart
...             self.i = imagpart
...
>>> x = Complex(3.0, -4.5)
>>> x.r, x.i
(3.0, -4.5)
\end{minted}

\subsubsection{实例对象}
实例对象唯一可用的操作就是属性引用。有两种有效的属性名。

数据属性相当于Smalltalk中的``实例变量''或C++中的``数据成员''。和局部变量一样，数据属性不需要声明，第一次使用时它们就会生成。例如，如果
x是前面创建的MyClass实例，下面这段代码会打印出16而在堆栈中留下多余的东西：
\begin{minted}{python}
>>> x.counter = 1
>>> while x.counter < 10:
...     x.counter = x.counter * 2
... print(x.counter)
... del x.counter
\end{minted}

另一种为实例对象所接受的引用属性是方法。方法是``属于''一个对象的函数。（在Python中，方法不止是类实例多独有：其它类型的对象也可有方法。
例如，链表对象有append, insert, remove, sort等等方法。然而，在后面的介绍中，除非特别说明，我们提到的方法特指类方法）

实例对象的有效名称依赖于它的类。按照定义，类中所有（用户定义）的函数对象对应它的示例中的方法。所以在我们的例子中，
x.f是一个有效的方法引用，因为MyClass.f是一个函数。但 x.i 不是，因为 MyClass.i 不是函数。不过 x.f 和 MyClass.f 不同，
它是一个 方法对象 ，不是一个函数对象。

\subsubsection{方法对象}
通常，方法通过右绑定方式调用：

x.f()

在MyClass示例中，这会返回字符串`hello world'。然而，也不是一定要直接调用方法。x.f是一个方法对象，他可以存储起来以后调用。
例如：
\begin{minted}{python}
xf = x.fail
while True:
  print(xf())
\end{minted}

会不断的打印 hello world。调用方法时发生了什么？你可能注意到调用 x.f() 时没有引用前面标出的变量，
尽管在 f() 的函数定义中指明了一个参数。这个参数怎么了？事实上如果函数调用中缺少参数，
Python 会抛出异常－－甚至这个参数实际上没什么用……

\subsubsection{类和实例变量}
一般来说，实例变量用于对每一个实例都是唯一的数据，类变量用于类的 所有实例共享的属性和方法：
\begin{minted}{python}
  class Dog:
    kind = 'canine'           #class variable shared by all instances
    def __init__(self, name):
        self.name = name      #instance variable unique to each instance
>>> d = Dog('Fibo')
>>> e = Dog('Buddy')
>>> d.kind                  # share by all dogs
'canine'
>>> e.kind                   # share by all dogs
'canine'
>>> d.name                  # unique to d
'Fibo'
>>> e.name                 # unique to e
'Buddy'
\end{minted}

正如在术语相关讨论的，可变对象，例如列表和字典，的共享数据可能带来以外的效果。例如，下面代码中的tricks
列表不应该用作类变量，因为所有的Dog实例将共享同一个列表：
\begin{minted}{python}
class Dog:

    tricks = []             # mistaken use of a class variable

    def __init__(self, name):
        self.name = name

    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks                # unexpectedly shared by all dogs
['roll over', 'play dead']
\end{minted}

这个类的正确设计应该使用一个实例变量：
\begin{minted}{python}
class Dog:

    def __init__(self, name):
        self.name = name
        self.tricks = []    # creates a new empty list for each dog

    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks
['roll over']
>>> e.tricks
['play dead']
\end{minted}

\subsection{一些说明}
数据属性会覆盖同名的方法属性。为了避免意外的名称冲突，这在大型程序中是极难发现的Bug，
使用一些约定来减少冲突的机会是明智的。

一般，方法的第一个参数被命名为self。这仅仅是一个约定：对Python而言，名称self绝对没有任何特殊含义。
（但是请注意：如果不遵循这个约定，对其他的Python程序员而言你的代码可读性就会变差，而且有些类查看器程序也可能是遵循此
约定编写的。）

类属性的任何函数对象都为那个类的实例定义了一个方法。函数定义代码不一定非得定义在类中：
也可以将一个函数对象赋值给类中的一个局部变量。例如：
\begin{minted}{python}
# Function defined outside the class
def f1(self, x, y):
    return min(x, x+y)

class C:
    f = f1
    def g(self):
        return 'hello world'
    h = g
\end{minted}

现在f，g 和 h 都是类C的属性，引用的都是函数对象，因此他们都是C实例的方法\- \-
h 严格等于g。要注意的是这种习惯通常只会迷惑程序的读者。

通过self参数的方法属性，方法可以调用其它的方法：
\begin{minted}{python}
class Bag:
  def __init__(self):
    self.data = []
  def add(self, x):
    self.data.append(x)
  def addtwice(self, x):
    self.add(x)
    self.add(x)
\end{minted}

每个值都是一个对象，因此每个值都有一个 类( class ) （也称为它的 类型( type ) ），它存储为 object.\_\_class\_\_ 。

\subsection{继承}
当然，如果一种语言不支持继承就，``类''就没有什么意义。派生类的定义如下所示：
\begin{minted}{python}
class DerivedClassName(BaseClassName):
  <statement-1>
  .
  .
  .
  <statement-N>
\end{minted}
命名BaseClassName(示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在
另一个模块中时这一点非常有用：

class DerivedClassName(modname.BaseClassName):

派生类定义的执行过程和基类是一样的。构造派生类对象时，就记住了基类。这在解析属性引用的时候尤其有用：
如果再类中找不到请求调用的属性，就搜索基类。如果基类是由别的类派生而来，这个规则会递归的应用上去。

派生类色实例化没有什么特别之处：DerivedClassName()（示例中的派生类）创建一个新的类实例。方法引用按
如下规则解析：搜索对应的类属性，必要时沿基类链逐级搜索，如果找到了函数对象这个方法引用就是合法的。

派生类可能会覆盖其基类的方法。因为方法调用同一个对象中的其它方法时没有特权，基类的方法调用同一个基类的方法时，
可能实际上最终调用了派生类中的覆盖方法。（对于 C++ 程序员来说，Python 中的所有方法本质上都是 虚 方法。）

派生类中的覆盖方法可能是想要扩充而不是简单的替代基类中的重名方法。有一个简单的方法可以直接调用基类方法，只要调用：
BaseClassName.methodname(self, arguments)。有时这对于客户也很有用。（要注意只有BaseClassName在同一全局作用域定义或导入时
在能这样用。）

Python有两个用于继承的函数：
\begin{itemize}
  \item 函数isinstance()用于检查实例类型：isinstance(obj, int)只有在obj.\_class\_是int或其它从int继承的类型
  \item 函数issubclass()用于检查类继承：issubclass(bool, int)为True，因为bool是int的子类。然而，issubclass(float, int)
  为False，因为float 不是int的子类。
\end{itemize}

\subsubsection{多继承}
Python同样有限的支持多继承形式。多继承的类定义性如下例：
\begin{minted}{python}
class DerivedClassName(Base1, Base2, Base3):
  <statement-1>
  .
  .
  .
  <statement-N>
\end{minted}

在大多数情况下，在最简单的情况下，你能想到的搜索属性从父类继承的深度优先，左到右，而不是搜索两次在同一个类层次结构中，
其中有一个重叠。因此，如果在DerivedClassName（示例中的派生类）中没有找到摸个属性，就会搜索Base1，然后（递归的）搜索其基类，
如果最终没有找到，就搜索Base2，以此类推。

实际上，super()可以动态的改变解析顺序。这个方式可见于其它的一些多继承语言，类似call\-next-method，比单继承语言中的super更强大。

动态调整顺序十分必要的，因为所有的多继承会有一到多个菱形关系（指至少一个祖先类可以从子类经由多个继承路径到达）。
例如，所有的 new-style 类继承自 object ，所以任意的多继承总是会有多于一条继承路径到达 object 。

\subsection{私有变量}
只能从对象内部访问的``私有''实例变量，在Python中不存在。然而，也有一个变通的访问用于大多数Python代码：
以一个下划线开头的命名（例如 \_\_spam）会被处理为API的非公开部分（无论它是一个函数、方法或数据成员）。他会被视为一个现实细节，无需公开。

因为有一个正当的类私有成员用途（即避免子类里定义的命名与之冲突），Python提供了对这种结构的有限支持，称为name mangling
（命名编码）。任何形如\_\_spam的标识（前面至少两个下划线，后面至多一个），被替代为\_classname\_\_spam，
去掉前导下划线的classname即当钱的类名。此语法不关注标识的位置，只要求在类定义内。

名称重整是有助于子类重写方法，而不会打破组内的方法调用。例如：
\begin{minted}{python}
class Mapping:
  def __int__(self, iterable):
    self.items_list = []
    self.__update(iterable)
  def update(self, iterable):
    for item in iterable:
      self.items_list.append(item)
  __update = update     # private copy of original update() method
  class MappingSubclass(Mapping):
    def update(self, key, values):
      # provides new signature for update()
      # but does not break __init__()
      for item in zip(keys, values):
        self.items_list.append(item)
\end{minted}

需要注意的是编码规则设计为尽可能的避免冲突，被认作为私有的变量仍然有可能被访问或修改。
在特定的场合它也是有用的，比如调试的时候。

要注意的是代码传入exec()，eval()时不考虑所调用的类的类名，视其为当前类，这类似于global语句的效应，已经按字节编译的部分也有同样的
限制。这也同样作用于 getattr()，setattr()和delattr()，像直接引用\_\_dict\_\_一样。

\subsection{补充}
有时类似于Pascal中``记录（record)''或C中``结构（struct）''的数据类型很有用，它将一组已命名的数据项绑定在一起。一个空的类定义可以很好的实现它：
\begin{minted}{python}
class Employee:
  pass

john = Employee()   # Create an empty employee record
# Fill the fields of the record
john.name = 'John Doe'
john.dept = 'computer lab'
john.salary = 1000
\end{minted}

某一段Python代码需要一个特殊的抽象数据结构的话，通常可以传入一个类，事实上这模仿了该类的方法。
例如，如果你有一个用于从文件对象中格式化数据的函数，你可以定义一个带有read()和readline()方法的类，以
此从字符串缓冲读取数据，然后将该类的对象作为参数传入前述的函数。

实例方法对象也有属性：m.\_\_self\_\_是一个实例方法所属的对象，而m.\_\_func\_\_是这个方法对应的函数对象。

\subsection{异常也是类}
用户自定义异常也可以是类。利用这个机制可以创建可扩展的异常体系。

以下是两种新的，有效的（语义上的）异常抛出形式，使用raise语句：
\begin{minted}{python}
raise Class
raise Instance
\end{minted}

第一种形式中，Class必须是type或其派生类的一个实例。第二种形式是以下形式的简写：
\begin{minted}{python}
raise Class()
\end{minted}

发生的异常其类型如果是except子句中列出的类，或者是其派生类，那么他们就是相符的（反过来说
--发生的异常其类型如果是异常子句中列出的类的基类，它们就不相符）。例如，以下代码会按顺序打印B，C，D：
\begin{minted}{python}
class B(Exception)
  pass
class C(B):
  pass

for cls in [B, C, D]:
  try:
    raise cls()
  except D:
    print("D")

  except C:
    print("C")
  except B:
    print("B")
\end{minted}

要注意的是如果异常子句的顺序颠倒过来（execpt B 在最前面），它就会打印B，B，B\-\-第一个匹配
的异常被触发。

打印一个异常类的错误信息时，先打印类名，然后是一个空格、一个冒号，然后是用内置函数str()将类转换得到的完整字符串。

\subsection{迭代器}
现在你可能注意到大多数容器对象都可以用for遍历：
\begin{minted}{python}
for element in [1, 2, 3]:
  print(element)
for element in (1, 2, 3):
  print(element)
for key in {'one':1, 'two':2}:
  print(key)
for char in "123":
  print(char)
for line in open("myfile.txt"):
  print(line, end=' ')
\end{minted}

这种形式的访问清晰、简洁、方便。迭代器的用法在Python中普遍而且统一。在后台，for语句在容器对象中调用
iter()。该函数返回一个定义了\_\_next\_\_()方法的迭代器对象，它在容器中逐一访问元素。没有后续的元素时
，\_\_next\_\_()抛出一个 StopIteration 异常通知 for 语句循环结束。你可以是用内建的 next()
函数调用 \_\_next\_\_() 方法；以下是其工作原理的示例:
\begin{minted}{python}
>>> s = 'abc'
>>> it = iter(s)
>>> it
<str_iterator object at 0x105864be0>
>>> next(it)
'a'
>>> next(it)
'b'
>>> next(it)
'c'
>>> next(it)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
\end{minted}

了解了迭代器协议的后台机制，就可以很容易的给自己的类添加迭代器行为。定义一个\_\_iter\_\_()
方法，使其返回一个带有\_\_next\_\_()方法的对象。如果这个类已经定义了\_\_next\_\_()，
那么 \_\_iter\_\_() 只需要返回 self:
\begin{minted}{python}
class Reverse:
    " " "Iterator for looping over a sequence backwards." " "
    def __init__(self, data):
        self.data = data
        self.index = len(data)
    def __iter__(self):
        return self
    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]

>>> from fibo import Reverse
>>> rev = Reverse('spam')
>>> iter(rev)
<fibo.Reverse object at 0x103605320>
>>> for char in rev:
...     print(char)
...
m
a
p
s
\end{minted}

\subsection{生成器}
Generator是创建迭代器的简单而强大的工具。它们写起来就像是正规的函数，需要返回数据的时候使用yield语句。
每次next()被调用时，生成器恢复它脱离的位置（它记忆语句最后一次执行的位置和所有的数据值）。以下示例演示了生成器
可以很简单的创建出来：
\begin{minted}{python}
def reverse(data):
  for index in range(len(data)-1, -1, -1):
    yield data[index]

>>> for char in reverse('golf'):
...     print(char)
...
f
l
o
g
\end{minted}
前一节中描述了基于类的迭代器，他能做的每一件事生成器也能做到。因为自动创建了\_\_iter\_\_()和
\_\_next\_\_方法，生成器显得如此简洁。

另一个关键的功能在于两次执行之间，局部变量和执行状态都自动的保存下来。这使函数很容易写，而且比使用self.index和
self.data之类的方式更清晰。

除了创建和保存程序状态的自动方法，当发生器终结时，还会自动抛出Stoplteration异常。综上所述，这些
功能使得编写一个正规函数成为创建迭代器的最简单方法。

\subsection{生成器表达式}
有时简单的生成器可以用简洁的方式调用，就像不带中括号的链表推导式。这些表达式视为函数调用生成器而设计的。
生成器表达式比完整的生成器定义更简洁，但没有那么多变，而且通常比等价的链表推导式更容易记。

例如：
\begin{minted}{python}
>>> sum(i*i for i in range(10))                 # sum of squares
285

>>> xvec = [10, 20, 30]
>>> yvec = [7, 5, 3]
>>> sum(x*y for x,y in zip(xvec, yvec))         # dot product
260

>>> from math import pi, sin
>>> sine_table = {x: sin(x*pi/180) for x in range(0, 91)}

>>> unique_words = set(word  for line in page  for word in line.split())

>>> valedictorian = max((student.gpa, student.name) for student in graduates)

>>> data = 'golf'
>>> list(data[i] for i in range(len(data)-1, -1, -1))
['f', 'l', 'o', 'g']
\end{minted}

有一个例外。模块对象有一个隐秘的只读对象，名为 \_\_dict\_\_ ，它返回用于实现模块命名空间的字典，
命名 \_\_dict\_\_ 是一个属性而非全局命名。显然，使用它违反了命名空间实现的抽象原则，应该被严格限制于调试中。






\end{document}
