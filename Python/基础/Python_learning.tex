%-*- coding: UTF-8 -*-
\documentclass[UTF8]{ctexart}
\usepackage{geometry}
\geometry{a4paper,centering,scale=0.8}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{float}
\usepackage{minted}

\title{\heiti Python 基础篇}
\author{卢婧宇}

\begin{document}
\maketitle
\tableofcontents

\newpage
\section{开胃菜}
虽然 Python 易于使用，但它却是一门完整的编程语言；与 Shell 脚本或批处理文件相比，它为编写大型程序提供了更多的结构和支持。
另一方面，Python提供了比C更多的错误检查，并且作为一门高级语言，它内置支持高级的数据结构类型，例如：灵活的数组和字典。

Python允许你将程序分割为不同的模块，以便在其他的Python程序中重用。Python内置提供了大量的标准模块，你可以将其用作程序的基础，
或者作为学习Python编程的示例。这些模块提供了诸如文件I/O、系统调用、Socket支持，甚至类似Tk的用户图形界面（GUI)工具包借口。

Python是一门解释型语言，因为无需编译和链接，你可以在程序开发中节省宝贵的时间。Python解释器可以交互的使用，这使得试验语言的特性、
编写临时程序或在自底向上的程序开发中测试方法非常容易。你甚至还可以把它当做一个桌面计算器。

Python让程序编写的紧凑和可读。用Python编写的程序通常比同样的C、C++或Java程序更短小，原因如下：
\begin{itemize}
  \item 高级数据结构使你可以在一条语句中表达复杂的操作
  \item 语句组使用缩进代替开始和结束大括号来组织
  \item 变量或参数无需声明
\end{itemize}

Python是可扩展的：如果你会C语言编程便可以轻易地为解释器\footnote{解释器，又译为直译器，是一种电脑程序，能够把高级编程语言一行一行直接转译运行。}
添加内置函数或模块，或者为了对性能瓶颈作优化，或者将Python程序与只有二进制形式的库（比如末各专业的商业图形库）连接起来。
一旦你真正掌握了它，你可以将Python解释器集成进某个C应用程序，并把它当作那个程序的扩展命令行语言。
\section{使用Python解释器}
\subsection{调用Python解释器}
Python解释器通常被安装在目标机器的 $/$usr$/$local$/$bin$/$python3.5 目录下。将 $/$usr$/$local$/$bin 目录包含进 Unix shell的搜索路径里，
以确保可以通过输入：Python3.5 命令启动。由于Python解释器的安装路径是可选的，这也可能是其他路径，你可以联系安装Python的用户或系统管理员确认
（例如，/usr/local/python 就是一个常见的选择）。文件结束符Unix系统是：Control + D

第二种启动Python解释器的方法是 Python -c command [arg] ...,这种方法可以在命令行执行Python语句，类似于shell中的 -c选项。由于Python语句通常会包含
空格或其他特殊shell字符，一般建议将命令用单引号包裹起来。

有一些Python模块也可以当做脚本使用。你可以使用 python -m module [arg] ... 命令调用它们，这类似在命令行中键入完整的路径名执行模块源文件一样。
使用脚本文件时，经常会运行脚本然后进入交互模式。这也可以通过在脚本之前加上 -i参数来实现。
\subsubsection{交互模式}
从tty读取命令时，我们称解释器工作于交互模式。这种模式下他根据主提示符来执行，主提示符通常标识为三个大于号（$>>>$);继续的部分被称为从属提示符，由三个
点标识（...)。在第一行之前，解释器打印欢迎信息、版本号和授权提示
\subsubsection{参数传递}
调用解释器时，脚本名和附加参数传入一个名为 sys.argv的字符串列表。你能够获取这个列表通过执行 import sys,列表的长度大于等于1；
没有给定脚本和参数时，它至少也有一个元素：sys.argv[0]此时为空字符串。脚本名指定为`-'（表示标准输入）时，sys.argv[0]被定义为`-',使用 -c 指令时，sys.argv[0]
被设定为`-c'。使用-m模块参数时，sys.argv[0]被设定为指定模块的全名。-c 指令或者 -m 模块之后的参数不会被Python解释器的选项处理机制所截获，而是留在sys.argv中，
供脚本命令操作。
\section{Python简介}
输入和输出分别由大括号和句号提示符（$>>>$ 和 ...)标注。

Python中的注释以\#字符起始，直至实际的行尾。注释可以从行首开始，也可以在空白或代码之后，但是不出现在字符串中。
文本字符串中的\#字符仅仅表示\#。
\subsection{将Python当做计算器}
\subsubsection{数字}
解释器表现得就像一个简单的计算器：可以向其录入一些表达式，它会给出返回值。表达式语法很直白：运算符$+，-，*$和$/$与其他语言一样；括号用于分组。

整数（例如，2，4，20）的类型是int，带有小数部分的数字（例如，5.0，1.6）的类型是float。Python2除法想要得到浮点型，除数或被除数应是浮点型。
Python3除法（$/$）永远返回一个浮点数,如果要使用floor除法并且得到整数结果（丢掉任何小数部分），可以使用（$//$）运算符；要计算余数使用 \% 。
可以使用$**$运算符计算幂乘方。用等号（$=$）用于给变量赋值。赋值之后在下一个提示符之前不会有任何结果显示。

变量在使用前必须“定义”（赋值），否则会出错。浮点数有完整的支持；整数和浮点数的混合计算中，整数会被转换为浮点数。

交互模式中，最近一个表达式的值赋给变量`\_'。这样我们就可以吧它当做一个桌面计算器：

\begin{minted}{python}
>>> t=12.5/100
>>> p=100.50
>>> p*t
12.5625
>>> p+ _
113.0625
\end{minted}

此变量对于用户是只读的。不要尝试给它赋值——你只会创建一个独立的同名局部变量，它屏蔽了系统内置变量的魔术效果。

除了int和float，Python还会支持其它数字类型，例如Decimal和Fraction。Python还内建支持复数，使用后缀 j 或 J 表示虚数部分
（例如，3+5j）。
\subsubsection{字符串}
相比数值，Python也提供了可以通过几种不同方式表示的字符串。它们可以用单引号（`...')或双引号（``...''）标识。
 \textbackslash 可以用来转义引号：
\begin{minted}{python}
>>> 'spam eggs' #single quotes
'spam eggs'
>>>'doesn\'t'  #use \' to escape the single quote...
"doesn't"
>>> '"Yes,"he said.'
'"Yes,"he said.'
>>> "\"Yes,\"he said."
'"Yes,"he said.'
>>> '"Isn\'t,"she said.'
'"Isn\'t,"she said.'
\end{minted}

在交互式解释其中，输出的字符串会用引号引起来，特殊字符会用反斜杠转义。虽然可能和输入看上去不太一样，但是两个字符串是相等的。
如果字符串中只有单引号而没有双引号，就用双引号引用，否则用单引号引用。
print()函数生成可读性更好的输出，它会省去引号并且打印出转义后的特殊字符：
\begin{minted}{python}
>>> '"Isn\'t,"she said.'
'"Isn\'t,"she said.'
>>> print('"Isn\'t." she said.')
"Isn't." she said.
>>> s='First line.\nSecond line.'  # \n means newline
>>> s  # without print(), \n is included in the output
'First line.\nSecond line.'
>>> print(s)  #with print(),\n produces a new line
First line.
Second line.
\end{minted}

如果你前面带有 \textbackslash 的字符被当作特殊字符，你可以使用原始字符串，方法是在第一个引号前面加上一个r。

字符串文本能够分成多行。一种方法是使用三引号：\verb|"""|...\verb|"""|或者 ```...'''。行尾换行符会自动包含到字符串中，
但是可以在行尾加上 \textbackslash
来避免这个行为。可以使用反斜杠为行结尾的字符串，他表示下一行在逻辑上是本行的后续内容。

字符串可以由 $+$ 操作符连接（粘到一起），可以由 $*$ 表示重复。相邻两个字符串文本自动连接在一起。
它只用于两个字符串文本，不能用于字符串表达式：
\begin{minted}{python}
>>> prefix='Py'
>>> prefix 'thon' # can't concatenate a variable and a string literal
...
SyntaxError: invalid syntax
>>> ('un'*3) 'ium'
...
SyntaxError: invalid syntax
\end{minted}


如果你想连接多个变量或者连接一个变量和一个字符串文本，使用 $+$。这个功能在你想切分很长的字符串的时候特别有用:
\begin{minted}{python}
>>> text=('Put several string within parerheses'
...       'to have them joined together.')
>>> text
'Put several string within parerhesesto have them joined together.'
\end{minted}

字符串也可以被截取（检索）。类似于C，字符串的第一个字符索引为0。Python没有单独的字符类型；一个字符就是一个简单的长度为1的字符串。
\begin{minted}{python}
>>> word='Python'
>>> word[0] # character in position 0
'P'
>>> word[5] # character in position 5
'n'
\end{minted}
索引也可以是负数，这将导致从右边开始计算。例如：
\begin{minted}{python}
>>> word[-1] #last character
'n'
>>> word[-2] #second-last character
'o'
>>> word[-6]
'P'
\end{minted}

请注意$-0$实际上就是0，所以他不会导致从右边开始计算。

除了索引，还支持切片。索引用于获得单个字符，切片让你获得一个子字符串:
\begin{minted}{python}
>>> word[0:2] # character from position 0(included)to 2 (excluded)
'Py'
>>> word[2:5] # character from position 2(included) to 5(excluded)
'tho'
\end{minted}

注意，包含起始的字符，不包含末尾的字符。这使得s[:i]+s[i:]永远等于s,：
\begin{minted}{python}
>>> word[:2]+word[2:]
'Python'
>>> word[:4]+word[4:]
'Python'
\end{minted}

切片的索引有非常有用的默认值；省略的第一个索引默认为零，省略的第二个索引默认为切片的字符串的大小。:
\begin{minted}{python}
>>> word[:2]
'Py'
>>> word[4:]
'on'
>>> word[-2:]
'on'
\end{minted}

有个办法可以很容易地记住切片的工作方式：切片时的索引是在两个字符之间。左边第一个字符的索引为0，而长度为n的字符串最后一个字符的右界索引为n。例如：

+---+---+---+---+---+---+

| P | y | t | h | o | n |

+---+---+---+---+---+---+

0   1   2   3   4   5   6

-6  -5  -4  -3  -2  -1

文本中的第一行数字给出字符串的索引点0...6。第二行给出相应的负索引。切片是从i到j两个数值表示的边界之间的所有字符。

对于非负索引，如果上下都在边界内，切片长度就是两个索引之差。

试图使用太大索引会导致错误。
\begin{minted}{python}
>>> word[42] # the word only has 6 characters
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
\end{minted}

Python能够优雅地处理那些没有意义的切片索引：一个过大的索引值（即下标值大于字符串实际长度）将被字符串实际长度所替代，
当上边界比下边界大时（即切片左值大于右值）就返回空字符串:
\begin{minted}{python}
>>> word[4:42]
'on'
>>> word[42:]
''
\end{minted}

Python字符串不可以被更改——它们是不可变的。因此，赋值给字符串索引的位置会导致错误。:
\begin{minted}{python}
>>> word[0]='J'
...
TypeError: 'str' object does not support item assignment
>>> word[2:]='py'
...
TypeError: 'str' object does not support item assignment
\end{minted}

如果你需要一个不同的字符串，你应该创建一个新的:
\begin{minted}{python}
>>> 'J'+word[1:]
'Jython'
>>> word[:2]+'py'
'Pypy'
\end{minted}

内置函数 len() 返回字符串长度:
\begin{minted}{python}
>>> s='supercalifragilisticexpialidocious'
>>> len(s)
34
\end{minted}

\subsubsection{列表}
Python有几个复合数据类型，用于表示其它的值。最通用的是list（列表），它可以写作中括号之间的一列逗号分隔的值。列标的元素不必是同一类型：
\begin{minted}{python}
>>> squares=[1, 4, 9, 16, 25]
>>> squares
[1, 4, 9, 16, 25]
\end{minted}

就像字符串（以及其它所有内建的序列类型）一样，列表可以被索引和切片：
\begin{minted}{python}
>>> squares[0] # indexing returns the item
1
>>> squares[-1]
25
>>> squares[-3:] #slicing return a new list
[9, 16, 25]
\end{minted}

所有的切片操作都会返回一个包含请求的元素的新列表。这意味着下面的切片操作返回列表一个新的（浅）拷贝副本：
\begin{minted}{python}
>>> squares[:]
[1, 4, 9, 16, 25]
\end{minted}

列表也支持连接这样的操作：
\begin{minted}{python}
>>> squares + [36, 49, 64, 81, 100]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
\end{minted}

不像不可变的字符串，列表是可变的，它允许修改元素：
\begin{minted}{python}
>>> cubes=[1, 8, 27, 65, 125] #something's wrong here
>>> 4 ** 3 #the cub of 4 is 64,not 65!
64
>>> cubes[3]=64 # replace the wrong value
>>> cubes
[1, 8, 27, 64, 125]
\end{minted}

还可以使用 append()方法在列表的末尾添加新的元素:
\begin{minted}{python}
>>> cubes.append(216) #add the cube of 6
>>> cubes.append(7 ** 3) # add the cube of 7
>>> cubes
[1, 8, 27, 64, 125, 216, 343]
\end{minted}

也可以对切片赋值，此操作可以改变列表的尺寸，或清空它：
\begin{minted}{python}
  >>> letters=['a','b','c','d','e','f','g']
  >>> letters
  ['a', 'b', 'c', 'd', 'e', 'f', 'g']
  >>> #replace some values
  ... letters[2:5]=['C','D','E']
  >>> letters
  ['a', 'b', 'C', 'D', 'E', 'f', 'g']
  >>> # now remove them
  ... letters[2:5]=[]
  >>> letters
  ['a', 'b', 'f', 'g']
  >>> # clear the list by replacing all the elements with an empty list
  ... letters[:]=[]
  >>> letters
  []
\end{minted}

内置函数 len() 同样适用于列表：
\begin{minted}{python}
  >>> letters=['a','b','c','d']
  >>> len(letters)
  4
\end{minted}

允许嵌套列表（创建一个包含洽谈列表的列表），例如：
\begin{minted}{python}
>>> a=['a','b','c']
>>> n=[1,2,3]
>>> x=[a,n]
>>> x
[['a', 'b', 'c'], [1, 2, 3]]
>>> x[0][1]
'b'
\end{minted}

\subsection{编程的第一步}
当然，我们可以使用Python完成比二加二更复杂的任务。例如，我们可以写一个生成斐波那契子程序的程序，如下所示：
\begin{minted}{python}
>>> # Fibonacci series:
... # the sum of two elements defines the next
... a, b = 0,1
>>> while b<10:
...    print(b)
...    a, b = b, a+b
...
1
1
2
3
5
8
\end{minted}

这个例子介绍了几个新功能。
\begin{itemize}
  \item 第一行包括了一个多重赋值：变量a 和b同时获得了新的值0和1最后一行又使用了一次。在这个演示中，变量赋值前，右边首先完成计算。右边的
  表达式从左到右计算。
  \item 条件（这里是 b<10）为true时，while循环执行。在Python中，类似于C，任何非零整数都是true;0是false。条件也是可以
  是字符串或列表，实际上可以使任何序列；所有长度不为零的是true，空序列是false。示例中的测试是一个检点的比较。
  标准比较操作符与C相同：< , > , == , <= , >= 和 ！=。
  \item 循环体是缩进的：缩进是Python组织语句的方法。Python(还)不提供集成的行编辑功能，所以你要为每一个缩
  进行输入TAB或空格。

  实践中建议你找个文本编辑来录入复杂的Python程序，大多数文本编辑器提供自动缩进。交互式录入复合语句时，必须在最后一个
  空行来标识结束（因为解释器没办法猜测你输入的哪一行是最后一行），需要注意的是同一个语句块中的每一行必须缩进同样数量的空白
  \item 关键字print() 语句输出给定表达式的值。它控制多个表达式和字符串输出为你想要字符串（就像在前面计算器的例子中那样）。

  字符串打印时不用引号包围，每两个子项之间插入空间，所以你可以把格式弄得很漂亮，像这样
  \begin{minted}{python}
    >>> i=256*256
    >>> print('The value of i is',i)
    The value of i is', 65536
  \end{minted}

  一个逗号结尾就可以禁止输出换行：
  \begin{minted}{python}
    >>> a, b=0 ,1
    >>> while b < 1000:
    ...     print(b, end=',')
    1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,
  \end{minted}
\end{itemize}

\section{深入Python流程控制}
除了前面介绍的while语句，Python还从其他语言借鉴了一些流程控制功能，并有所改变。
\subsection{if语句}
也许最有名的就是if语句。例如：
\begin{minted}{python}
  >>> x = int(input("Please enter an integer: "))
  Please enter an integer: 42
  >>> if x < 0:
  ...     x = 0
  ...     print('Negative changed to zero')
  ... elif x==0:
  ...     print('Zero')
  ... elif x==1:
  ...     print('Single')
  ... else:
  ...     print('More')
  ...
  More
\end{minted}
可能会有零到多个elif部分，else是可选的。关键字`elif'是`else if'的缩写，这个可以有效地避免
过深的缩进。if ... elif ... elif ...序列用于代替其他语言中的 swith 或 case 语句。
\subsection{for语句}
Python中的for语句和C或Pascal中的略有不同。通常的循环可能会依据一个等差数值步进过程（如Pascal）
，或由用户来定义迭代步骤和终止条件（如C），Python的for语句依据任意序列（链表或字符串）中的子项
，按它们在序列中的顺序来进行迭代。例如（没有暗指）：
\begin{minted}{python}
>>> # Measure some strings:
... words = ['cat', 'window', 'defenestrate']
>>> for w in words:
...     print(w, len(w))
...
cat 3
window 6
defenestrate 12
\end{minted}
在迭代过程中修改序列不安全（只有在使用链表这样的可变序列时才会有这样的情况）。
如果你想要修改你的迭代的序列（例如，复制选择项），你可以迭代它的副本。使用切割标识就可以很方便
的做到这一点：
\begin{minted}{python}
>>> for w in words[:]:
...     if len(w) > 6:
...             words.insert(0, w)
...
>>> words
['defenestrate', 'cat', 'window', 'defenestrate']
\end{minted}
\subsection{range()函数}
如果你需要一个数值序列，内置函数range()会很方便，它生成一个等差级数链表：
\begin{minted}{python}
>>> for i in range(5):
...     print(i)
...
0
1
2
3
4
\end{minted}
range(10)生成了一个包含10个值的链表，他用链表的索引值填充了这个长度为10的列表，
所生成的链表中不包括范围中的结束值。也可以让range()操作从另一个数值开始，或者可以指定一个不同
的步进值（甚至是负数，有时这也被称为步长)
\begin{minted}{python}
range(5, 10)
  5 through 9
range(0, 10, 3)
  0, 3, 6, 9
range(-10, -100, -30)
  -10, -40, -70
\end{minted}
需要迭代链表索引的话，如下所示结合使用用 range() 和 len()
\begin{minted}{python}
>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
...     print(i, a[i])
...
0 Mary
1 had
2 a
3 little
4 lamb
\end{minted}
不过，这种场合可以方便的使用 enumerate(),请参见 循环技巧。

如果你只是打印一个序列的话会发生奇怪的事情：
\begin{minted}{python}
>>> print(range(10))
range(0, 10)
\end{minted}
在不同方面range()函数返回的对象表现为它是一个列表，但事实上它并不是。当你迭代它时，
它是一个能够像期望的序列返回连续项的对象；但为了节省空间，他并不真正构造列表。

我们称此类对象是可迭代的，即适合作为那些期望从某些东西中获得连续项直到结束的函数
或结构的一个目标（参数）。我们已经见过的for语句就是这样一个迭代器。list()函数是
另外一个（迭代器），他从可迭代（对象）中创建列表：
\begin{minted}{python}
>>> list(range(5))
[0, 1, 2, 3, 4]
\end{minted}
稍后我们会看到更多返回可迭代（对象）和以可迭代（对象）作为参数的函数。

\subsection{break 和 continue 语句，以及循环中的else子句}
break语句和C中的类似，用于跳出最近的一级for或while循环。

循环可以有一个else子句；它在循环迭代完整个列表（对于for）或执行条件为false（对于while）时
执行，但循环被break中止的情况不会执行。以下搜索素数的示例程序演示了这个子句：
\begin{minted}{python}
>>> for n in range(2, 10):
...     for x in range(2, n):
...             if n % x == 0:
...                     print(n, 'equals', x, '*', n//x)
...                     break
...     else:
...         # loop fell through without finding s factor
...             print(n, 'is a prime number')
...
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3
\end{minted}
(Yes,这是正确的代码。看仔细：else 语句是属于 for 循环之中，不是 if 语句。)

与循环一起使用时，else子句与try语句的else子句比与if语句的具有更多的共同特点：try 语句的 else
子句在未出现异常时运行，循环的else子句在未出现break时运行。更多关于 try 语句和异常的内容，请参见异常处理。

continue 语句是从C中借鉴来的，它表示循环继续执行下一次迭代：
\begin{minted}{python}
  >>> for num in range(2, 10):
  ...     if num % 2 ==0:
  ...             print("Found an even number", num)
  ...             continue
  ...     print("Found a number", num)
  ...
  Found an even number 2
  Found a number 3
  Found an even number 4
  Found a number 5
  Found an even number 6
  Found a number 7
  Found an even number 8
  Found a number 9
\end{minted}

\subsection{pass语句}
pass语句什么也不做。它用于那些语法上必须要有什么语句，但程序什么也不做的场合，例如：
\begin{minted}{python}
  >>> while True:
  ...     pass # Busy-wait for keyboard interrupt (Ctrl+C)
  ...
\end{minted}
者通常用于创建最小结构的类：
\begin{minted}{python}
>>> class MyEmptyClass:
...     pass
...
\end{minted}
另一方面，pass可以在创建新代码时用来做函数或控制体的占位符。可以让你在更抽象的级别上思考。
pass可以默默的被忽视：
\begin{minted}{python}
>>> def initlog(*args):
...     pass  # Remember to implement this!
...
\end{minted}

\subsection{定义函数}
我们可以创建一个用来生成指定边界的斐波那契数列的函数：
\begin{minted}{python}
>>> def fib(n):  # write Fibonacci series up to n
...     """Print a Fibonacci series up to n."""
...     a, b = 0, 1
...     while a < n:
...             print(a, end=' ')
...             a, b = b, a+b
...     print()
...
>>> # Now call the function we just defined:
... fib(2000)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
\end{minted}

关键字 def 引入了一个函数定义。在其后必须跟有函数名和包括形式参数的圆括号。函数体语句从下一行
开始，必须是缩进的。

函数体第一行语句可以是可选的字符串文本，这个字符串是函数的文档字符串，或者称为 docstring。（更多关于 docstring 的
信息请参考文档字符串）有些工具通过 docstrings 自动生成在线的或可打印的文档，或者让用户通过代码交互浏览；
在你的代码中包含 docstrings 是一个好的实践，让它成为习惯吧。

函数调用会为函数局部变量生成一个新的符号表。确切的说，所有函数中的变量赋值都是将值存储在局部符号表。变量引用首先在局部符号表中
查找，然后是包含函数的局部符号表，最后是内置名字表。因此，全局变量不能在函数中直接赋值（除非用 global语句命名），尽管他们可以被引用。

函数引用的实际参数在函数调用时引入局部符号表，因此，实参总是传值调用（这里的值总是一个对象引用，而不是该对象的值）。
一个函数被另一个函数调用时，一个新的局部符号表在调用过程中被创建。

一个函数定义会在当前符号表内引入函数名。函数名指代的值（即函数体）有一个被Python 解释器认定为用户自定义函数的类型。这个值可以
赋予其他的名字（即变量名），然后它也可以被当做函数使用。这可以作为通用的重命名机制：
\begin{minted}{python}
>>> fib
<function fib at 0x102aa29d8>
>>> f=fib
>>> f(100)
0 1 1 2 3 5 8 13 21 34 55 89
\end{minted}
如果你使用过其他语言，你可能会反对说：fib不是一个函数，而是一个方法因为它并不返回任何值。事实上，没有return语句的函数确实会返回一个值，
虽然是一个相当令人厌烦的值（指None）。这个值被称为None(这是一个内建名称)。如果None值是唯一被书写的值，那么在写的时候通常会被解释器
忽略（即不输出任何内容）。如果你确实想看到这个值的输出内容，请使用print()函数：
\begin{minted}{python}
>>> fib(0)
>>> print(fib(0))
None
\end{minted}

定义一个返回斐波那契数列数字列表的函数，而不是打印它，是很简单的：
\begin{minted}{python}
>>> def fib2(n): #return Fibonacci series up to n
...     """Return a list containing the Fibonacci series up to n."""
...     result = []
...     a, b = 0, 1
...     while a < n:
...             result.append(a)  # see below
...             a, b = b, a+b
...     return result
...
>>> f100 = fib2(100) # call it
>>> f100             # write the reslut
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
\end{minted}

和以前一样，这个例子演示了一些新的Python功能：
\begin{itemize}
  \item return语句从函数中返回一个值，不带表达式的return返回None。过程结束后也会返回None。
  \item 语句result.append(b)称为链表对象 result的一个方法。方法是一个``属于''某个对象的函数，它被命名为obj.methodename,
  这里的obj是某个对象（可能是一个表达式），methodename是某个在该对象类型定义中的方法的命名。

  不同类型定义不同的方法。不同类型可能有同样名字的方法，但不会混淆。（当你定义自己的对象类型和方法时，可能会出现这种情况，
  class的定义方法详见类）。示例中演示的 append()方法由链表对象定义，它向链表中加入一个新元素。在示例中他等同于
  result =result +[a],不过效率更高。
\end{itemize}

\subsection{深入Python函数定义}
在Python中，你也可以定义包含若干参数的函数。这里有三种可用的形式，也可以混合使用。
\subsubsection{默认参数值}
最常用的一种形式是为一个或多个参数指定默认值。这会创建一个可以使用比定义时允许的参数更少的参数调用的函数，例如


\end{document}
